"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _zlib = _interopRequireDefault(require("zlib"));

var _stream = _interopRequireDefault(require("stream"));

var _url = _interopRequireDefault(require("url"));

var _JSONStream = _interopRequireDefault(require("JSONStream"));

var _debug = _interopRequireDefault(require("debug"));

var _lodash = _interopRequireDefault(require("lodash"));

var _request = _interopRequireDefault(require("request"));

var _streams = require("@verdaccio/streams");

var _utils = require("./utils");

var _logger = require("./logger");

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const debug = (0, _debug.default)('verdaccio:up-storage');

const encode = function (thing) {
  return encodeURIComponent(thing).replace(/^%40/, '@');
};

const jsonContentType = _constants.HEADERS.JSON;
const contentTypeAccept = `${jsonContentType};`;
/**
 * Just a helper (`config[key] || default` doesn't work because of zeroes)
 */

const setConfig = (config, key, def) => {
  return _lodash.default.isNil(config[key]) === false ? config[key] : def;
};
/**
 * Implements Storage interface
 * (same for storage.js, local-storage.js, up-storage.js)
 */


class ProxyStorage {
  // FIXME: upname is assigned to each instance
  // @ts-ignore
  // FIXME: proxy can be boolean or object, something smells here
  // @ts-ignore
  // @ts-ignore

  /**
   * Constructor
   * @param {*} config
   * @param {*} mainConfig
   */
  constructor(config, mainConfig) {
    _defineProperty(this, "config", void 0);

    _defineProperty(this, "failed_requests", void 0);

    _defineProperty(this, "userAgent", void 0);

    _defineProperty(this, "ca", void 0);

    _defineProperty(this, "logger", void 0);

    _defineProperty(this, "server_id", void 0);

    _defineProperty(this, "url", void 0);

    _defineProperty(this, "maxage", void 0);

    _defineProperty(this, "timeout", void 0);

    _defineProperty(this, "max_fails", void 0);

    _defineProperty(this, "fail_timeout", void 0);

    _defineProperty(this, "agent_options", void 0);

    _defineProperty(this, "upname", void 0);

    _defineProperty(this, "proxy", void 0);

    _defineProperty(this, "last_request_time", void 0);

    _defineProperty(this, "strict_ssl", void 0);

    this.config = config;
    this.failed_requests = 0; // @ts-ignore

    this.userAgent = mainConfig.user_agent;
    this.ca = config.ca;
    this.logger = _logger.logger;
    this.server_id = mainConfig.server_id;
    this.url = _url.default.parse(this.config.url); // $FlowFixMe

    this._setupProxy(this.url.hostname, config, mainConfig, this.url.protocol === 'https:');

    this.config.url = this.config.url.replace(/\/$/, '');

    if (this.config.timeout && Number(this.config.timeout) >= 1000) {
      this.logger.warn(['Too big timeout value: ' + this.config.timeout, 'We changed time format to nginx-like one', '(see http://nginx.org/en/docs/syntax.html)', 'so please update your config accordingly'].join('\n'));
    } // a bunch of different configurable timers


    this.maxage = (0, _utils.parseInterval)(setConfig(this.config, 'maxage', '2m'));
    this.timeout = (0, _utils.parseInterval)(setConfig(this.config, 'timeout', '30s'));
    this.max_fails = Number(setConfig(this.config, 'max_fails', 2));
    this.fail_timeout = (0, _utils.parseInterval)(setConfig(this.config, 'fail_timeout', '5m'));
    this.strict_ssl = Boolean(setConfig(this.config, 'strict_ssl', true));
    this.agent_options = setConfig(this.config, 'agent_options', {
      keepAlive: true,
      maxSockets: 40,
      maxFreeSockets: 10
    });
  }
  /**
   * Fetch an asset.
   * @param {*} options
   * @param {*} cb
   * @return {Request}
   */


  request(options, cb) {
    let json;

    if (this._statusCheck() === false) {
      const streamRead = new _stream.default.Readable();
      process.nextTick(function () {
        if (cb) {
          cb(_utils.ErrorCode.getInternalError(_constants.API_ERROR.UPLINK_OFFLINE));
        }

        streamRead.emit('error', _utils.ErrorCode.getInternalError(_constants.API_ERROR.UPLINK_OFFLINE));
      }); // $FlowFixMe

      streamRead._read = function () {}; // preventing 'Uncaught, unspecified "error" event'


      streamRead.on('error', function () {});
      return streamRead;
    }

    const self = this;

    const headers = this._setHeaders(options);

    this._addProxyHeaders(options.req, headers);

    this._overrideWithUpLinkConfLocaligHeaders(headers);

    const method = options.method || 'GET';
    const uri = options.uri_full || this.config.url + options.uri;
    self.logger.info({
      method: method,
      headers: headers,
      uri: uri
    }, "making request: '@{method} @{uri}'");

    if ((0, _utils.isObject)(options.json)) {
      json = JSON.stringify(options.json);
      headers['Content-Type'] = headers['Content-Type'] || _constants.HEADERS.JSON;
    }

    const requestCallback = cb ? function (err, res, body) {
      let error;
      const responseLength = err ? 0 : body.length; // $FlowFixMe

      processBody();
      logActivity(); // $FlowFixMe

      cb(err, res, body);
      /**
       * Perform a decode.
       */

      function processBody() {
        if (err) {
          error = err.message;
          return;
        }

        if (options.json && res.statusCode < 300) {
          try {
            // $FlowFixMe
            body = JSON.parse(body.toString(_constants.CHARACTER_ENCODING.UTF8));
          } catch (_err) {
            body = {};
            err = _err;
            error = err.message;
          }
        }

        if (!err && (0, _utils.isObject)(body)) {
          if (_lodash.default.isString(body.error)) {
            error = body.error;
          }
        }
      }
      /**
       * Perform a log.
       */


      function logActivity() {
        let message = "@{!status}, req: '@{request.method} @{request.url}'";
        message += error ? ', error: @{!error}' : ', bytes: @{bytes.in}/@{bytes.out}';
        self.logger.http({
          err: err || undefined,
          // if error is null/false change this to undefined so it wont log
          request: {
            method: method,
            url: uri
          },
          status: res != null ? res.statusCode : 'ERR',
          error: error,
          bytes: {
            in: json ? json.length : 0,
            out: responseLength || 0
          }
        }, message);
      }
    } : undefined;
    let requestOptions = {
      url: uri,
      method: method,
      headers: headers,
      body: json,
      proxy: this.proxy,
      encoding: null,
      gzip: true,
      timeout: this.timeout,
      strictSSL: this.strict_ssl,
      agentOptions: this.agent_options
    };

    if (this.ca) {
      requestOptions = Object.assign({}, requestOptions, {
        ca: this.ca
      });
    }

    const req = (0, _request.default)(requestOptions, requestCallback);
    let statusCalled = false;
    req.on('response', function (res) {
      // FIXME: _verdaccio_aborted seems not used
      // @ts-ignore
      if (!req._verdaccio_aborted && !statusCalled) {
        statusCalled = true;

        self._statusCheck(true);
      }

      if (_lodash.default.isNil(requestCallback) === false) {
        (function do_log() {
          const message = "@{!status}, req: '@{request.method} @{request.url}' (streaming)";
          self.logger.http({
            request: {
              method: method,
              url: uri
            },
            status: _lodash.default.isNull(res) === false ? res.statusCode : 'ERR'
          }, message);
        })();
      }
    });
    req.on('error', function (_err) {
      // FIXME: _verdaccio_aborted seems not used
      // @ts-ignore
      if (!req._verdaccio_aborted && !statusCalled) {
        statusCalled = true;

        self._statusCheck(false);
      }
    }); // @ts-ignore

    return req;
  }
  /**
   * Set default headers.
   * @param {Object} options
   * @return {Object}
   * @private
   */


  _setHeaders(options) {
    var _options$req;

    const headers = options.headers || {};
    const accept = _constants.HEADERS.ACCEPT;
    const acceptEncoding = _constants.HEADERS.ACCEPT_ENCODING;
    const userAgent = _constants.HEADERS.USER_AGENT;
    headers[accept] = headers[accept] || contentTypeAccept;
    headers[acceptEncoding] = headers[acceptEncoding] || 'gzip'; // registry.npmjs.org will only return search result if user-agent include string 'npm'

    headers[userAgent] = this.userAgent ? `npm (${this.userAgent})` : (_options$req = options.req) === null || _options$req === void 0 ? void 0 : _options$req.get('user-agent');
    return this._setAuth(headers);
  }
  /**
   * Validate configuration auth and assign Header authorization
   * @param {Object} headers
   * @return {Object}
   * @private
   */


  _setAuth(headers) {
    const {
      auth
    } = this.config;

    if (_lodash.default.isNil(auth) || headers[_constants.HEADERS.AUTHORIZATION]) {
      return headers;
    }

    if (_lodash.default.isObject(auth) === false && _lodash.default.isObject(auth.token) === false) {
      this._throwErrorAuth('Auth invalid');
    } // get NPM_TOKEN http://blog.npmjs.org/post/118393368555/deploying-with-npm-private-modules
    // or get other variable export in env
    // https://github.com/verdaccio/verdaccio/releases/tag/v2.5.0


    let token;
    const tokenConf = auth;

    if (_lodash.default.isNil(tokenConf.token) === false && _lodash.default.isString(tokenConf.token)) {
      token = tokenConf.token;
    } else if (_lodash.default.isNil(tokenConf.token_env) === false) {
      if (_lodash.default.isString(tokenConf.token_env)) {
        token = process.env[tokenConf.token_env];
      } else if (_lodash.default.isBoolean(tokenConf.token_env) && tokenConf.token_env) {
        token = process.env.NPM_TOKEN;
      } else {
        this.logger.error(_constants.ERROR_CODE.token_required);

        this._throwErrorAuth(_constants.ERROR_CODE.token_required);
      }
    } else {
      token = process.env.NPM_TOKEN;
    }

    if (_lodash.default.isNil(token)) {
      this._throwErrorAuth(_constants.ERROR_CODE.token_required);
    } // define type Auth allow basic and bearer


    const type = tokenConf.type || _constants.TOKEN_BASIC;

    this._setHeaderAuthorization(headers, type, token);

    return headers;
  }
  /**
   * @param {string} message
   * @throws {Error}
   * @private
   */


  _throwErrorAuth(message) {
    this.logger.error(message);
    throw new Error(message);
  }
  /**
   * Assign Header authorization with type authentication
   * @param {Object} headers
   * @param {string} type
   * @param {string} token
   * @private
   */


  _setHeaderAuthorization(headers, type, token) {
    const _type = type.toLowerCase();

    if (_type !== _constants.TOKEN_BEARER.toLowerCase() && _type !== _constants.TOKEN_BASIC.toLowerCase()) {
      this._throwErrorAuth(`Auth type '${_type}' not allowed`);
    }

    type = _lodash.default.upperFirst(type);
    headers[_constants.HEADERS.AUTHORIZATION] = (0, _utils.buildToken)(type, token);
  }
  /**
   * It will add or override specified headers from config file.
   *
   * Eg:
   *
   * uplinks:
   npmjs:
   url: https://registry.npmjs.org/
   headers:
   Accept: "application/vnd.npm.install-v2+json; q=1.0"
   verdaccio-staging:
   url: https://mycompany.com/npm
   headers:
   Accept: "application/json"
   authorization: "Basic YourBase64EncodedCredentials=="
    * @param {Object} headers
   * @private
   */


  _overrideWithUpLinkConfLocaligHeaders(headers) {
    if (!this.config.headers) {
      return headers;
    } // add/override headers specified in the config

    /* eslint guard-for-in: 0 */


    for (const key in this.config.headers) {
      headers[key] = this.config.headers[key];
    }
  }
  /**
   * Determine whether can fetch from the provided URL
   * @param {*} url
   * @return {Boolean}
   */


  isUplinkValid(url) {
    // $FlowFixMe
    const urlParsed = _url.default.parse(url);

    const isHTTPS = urlDomainParsed => urlDomainParsed.protocol === 'https:' && (urlParsed.port === null || urlParsed.port === '443');

    const getHost = urlDomainParsed => isHTTPS(urlDomainParsed) ? urlDomainParsed.hostname : urlDomainParsed.host;

    const isMatchProtocol = urlParsed.protocol === this.url.protocol;
    const isMatchHost = getHost(urlParsed) === getHost(this.url); // @ts-ignore

    const isMatchPath = urlParsed.path.indexOf(this.url.path) === 0;
    return isMatchProtocol && isMatchHost && isMatchPath;
  }
  /**
   * Get a remote package metadata
   * @param {*} name package name
   * @param {*} options request options, eg: eTag.
   * @param {*} callback
   */


  getRemoteMetadata(name, options, callback) {
    const headers = {};

    if (_lodash.default.isNil(options.etag) === false) {
      headers['If-None-Match'] = options.etag;
      headers[_constants.HEADERS.ACCEPT] = contentTypeAccept;
    }

    this.request({
      uri: `/${encode(name)}`,
      json: true,
      headers: headers,
      req: options.req
    }, (err, res, body) => {
      if (err) {
        return callback(err);
      }

      if (res.statusCode === _constants.HTTP_STATUS.NOT_FOUND) {
        return callback(_utils.ErrorCode.getNotFound(_constants.API_ERROR.NOT_PACKAGE_UPLINK));
      }

      if (!(res.statusCode >= _constants.HTTP_STATUS.OK && res.statusCode < _constants.HTTP_STATUS.MULTIPLE_CHOICES)) {
        const error = _utils.ErrorCode.getInternalError(`${_constants.API_ERROR.BAD_STATUS_CODE}: ${res.statusCode}`); // $FlowFixMe


        error.remoteStatus = res.statusCode;
        return callback(error);
      }

      callback(null, body, res.headers.etag);
    });
  }
  /**
   * Fetch a tarball from the uplink.
   * @param {String} url
   * @return {Stream}
   */


  fetchTarball(url) {
    const stream = new _streams.ReadTarball({});
    let current_length = 0;
    let expected_length;

    stream.abort = () => {};

    const readStream = this.request({
      uri_full: url,
      encoding: null,
      headers: {
        Accept: contentTypeAccept
      }
    });
    readStream.on('response', function (res) {
      if (res.statusCode === _constants.HTTP_STATUS.NOT_FOUND) {
        return stream.emit('error', _utils.ErrorCode.getNotFound(_constants.API_ERROR.NOT_FILE_UPLINK));
      }

      if (!(res.statusCode >= _constants.HTTP_STATUS.OK && res.statusCode < _constants.HTTP_STATUS.MULTIPLE_CHOICES)) {
        return stream.emit('error', _utils.ErrorCode.getInternalError(`bad uplink status code: ${res.statusCode}`));
      }

      if (res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH]) {
        expected_length = res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH];
        stream.emit(_constants.HEADER_TYPE.CONTENT_LENGTH, res.headers[_constants.HEADER_TYPE.CONTENT_LENGTH]);
      }

      readStream.pipe(stream);
    });
    readStream.on('error', function (err) {
      stream.emit('error', err);
    });
    readStream.on('data', function (data) {
      current_length += data.length;
    });
    readStream.on('end', function (data) {
      if (data) {
        current_length += data.length;
      }

      if (expected_length && current_length != expected_length) {
        stream.emit('error', _utils.ErrorCode.getInternalError(_constants.API_ERROR.CONTENT_MISMATCH));
      }
    });
    return stream;
  }
  /**
   * Perform a stream search.
   * @param {*} options request options
   * @return {Stream}
   */


  search(options) {
    const transformStream = new _stream.default.PassThrough({
      objectMode: true
    });
    const requestStream = this.request({
      uri: options.req.url,
      req: options.req,
      headers: {
        // query for search
        referer: options.req.get('referer')
      }
    });

    const parsePackage = pkg => {
      if ((0, _utils.isObjectOrArray)(pkg)) {
        transformStream.emit('data', pkg);
      }
    };

    requestStream.on('response', res => {
      if (!String(res.statusCode).match(/^2\d\d$/)) {
        return transformStream.emit('error', _utils.ErrorCode.getInternalError(`bad status code ${res.statusCode} from uplink`));
      } // See https://github.com/request/request#requestoptions-callback
      // Request library will not decode gzip stream.


      let jsonStream;

      if (res.headers[_constants.HEADER_TYPE.CONTENT_ENCODING] === _constants.HEADERS.GZIP) {
        jsonStream = res.pipe(_zlib.default.createUnzip());
      } else {
        jsonStream = res;
      }

      jsonStream.pipe(_JSONStream.default.parse('*')).on('data', parsePackage);
      jsonStream.on('end', () => {
        transformStream.emit('end');
      });
    });
    requestStream.on('error', err => {
      transformStream.emit('error', err);
    });

    transformStream.abort = () => {
      // FIXME: this is clearly a potential issue
      // there is no abort method on Stream.Readable
      // @ts-ignore
      requestStream.abort();
      transformStream.emit('end');
    };

    return transformStream;
  }
  /**
   * Add proxy headers.
   * FIXME: object mutations, it should return an new object
   * @param {*} req the http request
   * @param {*} headers the request headers
   */


  _addProxyHeaders(req, headers) {
    if (req) {
      // Only submit X-Forwarded-For field if we don't have a proxy selected
      // in the config file.
      //
      // Otherwise misconfigured proxy could return 407:
      // https://github.com/rlidwka/sinopia/issues/254
      //
      // FIXME: proxy logic is odd, something is wrong here.
      // @ts-ignore
      if (!this.proxy) {
        headers['x-forwarded-for'] = (req.get('x-forwarded-for') ? req.get('x-forwarded-for') + ', ' : '') + req.connection.remoteAddress;
      }
    } // always attach Via header to avoid loops, even if we're not proxying


    headers['via'] = req && req.get('via') ? req.get('via') + ', ' : '';
    headers['via'] += '1.1 ' + this.server_id + ' (Verdaccio)';
  }
  /**
   * Check whether the remote host is available.
   * @param {*} alive
   * @return {Boolean}
   */


  _statusCheck(alive) {
    if (arguments.length === 0) {
      return this._ifRequestFailure() === false;
    }

    if (alive) {
      if (this.failed_requests >= this.max_fails) {
        this.logger.warn({
          host: this.url.host
        }, 'host @{host} is back online');
      }

      this.failed_requests = 0;
    } else {
      this.failed_requests++;

      if (this.failed_requests === this.max_fails) {
        this.logger.warn({
          host: this.url.host
        }, 'host @{host} is now offline');
      }
    }

    this.last_request_time = Date.now();
  }
  /**
   * If the request failure.
   * @return {boolean}
   * @private
   */


  _ifRequestFailure() {
    return this.failed_requests >= this.max_fails && Math.abs(Date.now() - this.last_request_time) < this.fail_timeout;
  }
  /**
   * Set up a proxy.
   * @param {*} hostname
   * @param {*} config
   * @param {*} mainconfig
   * @param {*} isHTTPS
   */


  _setupProxy(hostname, config, mainconfig, isHTTPS) {
    let noProxyList;
    const proxy_key = isHTTPS ? 'https_proxy' : 'http_proxy'; // get http_proxy and no_proxy configs

    if (proxy_key in config) {
      this.proxy = config[proxy_key];
    } else if (proxy_key in mainconfig) {
      this.proxy = mainconfig[proxy_key];
    }

    if ('no_proxy' in config) {
      // $FlowFixMe
      noProxyList = config.no_proxy;
    } else if ('no_proxy' in mainconfig) {
      noProxyList = mainconfig.no_proxy;
    } // use wget-like algorithm to determine if proxy shouldn't be used


    if (hostname[0] !== '.') {
      hostname = '.' + hostname;
    }

    if (_lodash.default.isString(noProxyList) && noProxyList.length) {
      // $FlowFixMe
      noProxyList = noProxyList.split(',');
    }

    if (_lodash.default.isArray(noProxyList)) {
      for (let i = 0; i < noProxyList.length; i++) {
        let noProxyItem = noProxyList[i];

        if (noProxyItem[0] !== '.') {
          noProxyItem = '.' + noProxyItem;
        }

        if (hostname.lastIndexOf(noProxyItem) === hostname.length - noProxyItem.length) {
          if (this.proxy) {
            debug('not using proxy for %o, excluded by %o rule', this.url.href, noProxyItem); // @ts-ignore

            this.proxy = false;
          }

          break;
        }
      }
    } // if it's non-string (i.e. "false"), don't use it


    if (_lodash.default.isString(this.proxy) === false) {
      // @ts-ignore
      delete this.proxy;
    } else {
      debug('using proxy %o for %o', this.url.href, this.proxy);
    }
  }

}

var _default = ProxyStorage;
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdXAtc3RvcmFnZS50cyJdLCJuYW1lcyI6WyJkZWJ1ZyIsImVuY29kZSIsInRoaW5nIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsImpzb25Db250ZW50VHlwZSIsIkhFQURFUlMiLCJKU09OIiwiY29udGVudFR5cGVBY2NlcHQiLCJzZXRDb25maWciLCJjb25maWciLCJrZXkiLCJkZWYiLCJfIiwiaXNOaWwiLCJQcm94eVN0b3JhZ2UiLCJjb25zdHJ1Y3RvciIsIm1haW5Db25maWciLCJmYWlsZWRfcmVxdWVzdHMiLCJ1c2VyQWdlbnQiLCJ1c2VyX2FnZW50IiwiY2EiLCJsb2dnZXIiLCJzZXJ2ZXJfaWQiLCJ1cmwiLCJVUkwiLCJwYXJzZSIsIl9zZXR1cFByb3h5IiwiaG9zdG5hbWUiLCJwcm90b2NvbCIsInRpbWVvdXQiLCJOdW1iZXIiLCJ3YXJuIiwiam9pbiIsIm1heGFnZSIsIm1heF9mYWlscyIsImZhaWxfdGltZW91dCIsInN0cmljdF9zc2wiLCJCb29sZWFuIiwiYWdlbnRfb3B0aW9ucyIsImtlZXBBbGl2ZSIsIm1heFNvY2tldHMiLCJtYXhGcmVlU29ja2V0cyIsInJlcXVlc3QiLCJvcHRpb25zIiwiY2IiLCJqc29uIiwiX3N0YXR1c0NoZWNrIiwic3RyZWFtUmVhZCIsIlN0cmVhbSIsIlJlYWRhYmxlIiwicHJvY2VzcyIsIm5leHRUaWNrIiwiRXJyb3JDb2RlIiwiZ2V0SW50ZXJuYWxFcnJvciIsIkFQSV9FUlJPUiIsIlVQTElOS19PRkZMSU5FIiwiZW1pdCIsIl9yZWFkIiwib24iLCJzZWxmIiwiaGVhZGVycyIsIl9zZXRIZWFkZXJzIiwiX2FkZFByb3h5SGVhZGVycyIsInJlcSIsIl9vdmVycmlkZVdpdGhVcExpbmtDb25mTG9jYWxpZ0hlYWRlcnMiLCJtZXRob2QiLCJ1cmkiLCJ1cmlfZnVsbCIsImluZm8iLCJzdHJpbmdpZnkiLCJyZXF1ZXN0Q2FsbGJhY2siLCJlcnIiLCJyZXMiLCJib2R5IiwiZXJyb3IiLCJyZXNwb25zZUxlbmd0aCIsImxlbmd0aCIsInByb2Nlc3NCb2R5IiwibG9nQWN0aXZpdHkiLCJtZXNzYWdlIiwic3RhdHVzQ29kZSIsInRvU3RyaW5nIiwiQ0hBUkFDVEVSX0VOQ09ESU5HIiwiVVRGOCIsIl9lcnIiLCJpc1N0cmluZyIsImh0dHAiLCJ1bmRlZmluZWQiLCJzdGF0dXMiLCJieXRlcyIsImluIiwib3V0IiwicmVxdWVzdE9wdGlvbnMiLCJwcm94eSIsImVuY29kaW5nIiwiZ3ppcCIsInN0cmljdFNTTCIsImFnZW50T3B0aW9ucyIsIk9iamVjdCIsImFzc2lnbiIsInN0YXR1c0NhbGxlZCIsIl92ZXJkYWNjaW9fYWJvcnRlZCIsImRvX2xvZyIsImlzTnVsbCIsImFjY2VwdCIsIkFDQ0VQVCIsImFjY2VwdEVuY29kaW5nIiwiQUNDRVBUX0VOQ09ESU5HIiwiVVNFUl9BR0VOVCIsImdldCIsIl9zZXRBdXRoIiwiYXV0aCIsIkFVVEhPUklaQVRJT04iLCJpc09iamVjdCIsInRva2VuIiwiX3Rocm93RXJyb3JBdXRoIiwidG9rZW5Db25mIiwidG9rZW5fZW52IiwiZW52IiwiaXNCb29sZWFuIiwiTlBNX1RPS0VOIiwiRVJST1JfQ09ERSIsInRva2VuX3JlcXVpcmVkIiwidHlwZSIsIlRPS0VOX0JBU0lDIiwiX3NldEhlYWRlckF1dGhvcml6YXRpb24iLCJFcnJvciIsIl90eXBlIiwidG9Mb3dlckNhc2UiLCJUT0tFTl9CRUFSRVIiLCJ1cHBlckZpcnN0IiwiaXNVcGxpbmtWYWxpZCIsInVybFBhcnNlZCIsImlzSFRUUFMiLCJ1cmxEb21haW5QYXJzZWQiLCJwb3J0IiwiZ2V0SG9zdCIsImhvc3QiLCJpc01hdGNoUHJvdG9jb2wiLCJpc01hdGNoSG9zdCIsImlzTWF0Y2hQYXRoIiwicGF0aCIsImluZGV4T2YiLCJnZXRSZW1vdGVNZXRhZGF0YSIsIm5hbWUiLCJjYWxsYmFjayIsImV0YWciLCJIVFRQX1NUQVRVUyIsIk5PVF9GT1VORCIsImdldE5vdEZvdW5kIiwiTk9UX1BBQ0tBR0VfVVBMSU5LIiwiT0siLCJNVUxUSVBMRV9DSE9JQ0VTIiwiQkFEX1NUQVRVU19DT0RFIiwicmVtb3RlU3RhdHVzIiwiZmV0Y2hUYXJiYWxsIiwic3RyZWFtIiwiUmVhZFRhcmJhbGwiLCJjdXJyZW50X2xlbmd0aCIsImV4cGVjdGVkX2xlbmd0aCIsImFib3J0IiwicmVhZFN0cmVhbSIsIkFjY2VwdCIsIk5PVF9GSUxFX1VQTElOSyIsIkhFQURFUl9UWVBFIiwiQ09OVEVOVF9MRU5HVEgiLCJwaXBlIiwiZGF0YSIsIkNPTlRFTlRfTUlTTUFUQ0giLCJzZWFyY2giLCJ0cmFuc2Zvcm1TdHJlYW0iLCJQYXNzVGhyb3VnaCIsIm9iamVjdE1vZGUiLCJyZXF1ZXN0U3RyZWFtIiwicmVmZXJlciIsInBhcnNlUGFja2FnZSIsInBrZyIsIlN0cmluZyIsIm1hdGNoIiwianNvblN0cmVhbSIsIkNPTlRFTlRfRU5DT0RJTkciLCJHWklQIiwiemxpYiIsImNyZWF0ZVVuemlwIiwiSlNPTlN0cmVhbSIsImNvbm5lY3Rpb24iLCJyZW1vdGVBZGRyZXNzIiwiYWxpdmUiLCJhcmd1bWVudHMiLCJfaWZSZXF1ZXN0RmFpbHVyZSIsImxhc3RfcmVxdWVzdF90aW1lIiwiRGF0ZSIsIm5vdyIsIk1hdGgiLCJhYnMiLCJtYWluY29uZmlnIiwibm9Qcm94eUxpc3QiLCJwcm94eV9rZXkiLCJub19wcm94eSIsInNwbGl0IiwiaXNBcnJheSIsImkiLCJub1Byb3h5SXRlbSIsImxhc3RJbmRleE9mIiwiaHJlZiJdLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUdBOztBQUNBOztBQUNBOzs7Ozs7QUFFQSxNQUFNQSxLQUFLLEdBQUcsb0JBQVcsc0JBQVgsQ0FBZDs7QUFFQSxNQUFNQyxNQUFNLEdBQUcsVUFBVUMsS0FBVixFQUF5QjtBQUN0QyxTQUFPQyxrQkFBa0IsQ0FBQ0QsS0FBRCxDQUFsQixDQUEwQkUsT0FBMUIsQ0FBa0MsTUFBbEMsRUFBMEMsR0FB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VyxDQUFDSyxDQUFELENBQTdCOztBQUNBLFlBQUlDLFdBQVcsQ0FBQyxDQUFELENBQVgsS0FBbUIsR0FBdkIsRUFBNEI7QUFDMUJBLFVBQUFBLFdBQVcsR0FBRyxNQUFNQSxXQUFwQjtBQUNEOztBQUNELFlBQUkvSyxRQUFRLENBQUNnTCxXQUFULENBQXFCRCxXQUFyQixNQUFzQy9LLFFBQVEsQ0FBQ2lELE1BQVQsR0FBa0I4SCxXQUFXLENBQUM5SCxNQUF4RSxFQUFnRjtBQUM5RSxjQUFJLEtBQUtpQixLQUFULEVBQWdCO0FBQ2Q5RixZQUFBQSxLQUFLLENBQUMsNkNBQUQsRUFBZ0QsS0FBS3dCLEdBQUwsQ0FBU3FMLElBQXpELEVBQStERixXQUEvRCxDQUFMLENBRGMsQ0FFZDs7QUFDQSxpQkFBSzdHLEtBQUwsR0FBYSxLQUFiO0FBQ0Q7O0FBQ0Q7QUFDRDtBQUNGO0FBQ0YsS0ExQ3dHLENBNEN6Rzs7O0FBQ0EsUUFBSWpGLGdCQUFFeUUsUUFBRixDQUFXLEtBQUtRLEtBQWhCLE1BQTJCLEtBQS9CLEVBQXNDO0FBQ3BDO0FBQ0EsYUFBTyxLQUFLQSxLQUFaO0FBQ0QsS0FIRCxNQUdPO0FBQ0w5RixNQUFBQSxLQUFLLENBQUMsdUJBQUQsRUFBMEIsS0FBS3dCLEdBQUwsQ0FBU3FMLElBQW5DLEVBQXlDLEtBQUsvRyxLQUE5QyxDQUFMO0FBQ0Q7QUFDRjs7QUEzb0JrQzs7ZUE4b0J0Qi9FLFkiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgemxpYiBmcm9tICd6bGliJztcbmltcG9ydCBTdHJlYW0gZnJvbSAnc3RyZWFtJztcbmltcG9ydCBVUkwsIHsgVXJsV2l0aFN0cmluZ1F1ZXJ5IH0gZnJvbSAndXJsJztcbmltcG9ydCBKU09OU3RyZWFtIGZyb20gJ0pTT05TdHJlYW0nO1xuaW1wb3J0IGJ1aWxkRGVidWcgZnJvbSAnZGVidWcnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCByZXF1ZXN0IGZyb20gJ3JlcXVlc3QnO1xuaW1wb3J0IHsgUmVhZFRhcmJhbGwgfSBmcm9tICdAdmVyZGFjY2lvL3N0cmVhbXMnO1xuaW1wb3J0IHsgQ29uZmlnLCBDYWxsYmFjaywgSGVhZGVycywgTG9nZ2VyLCBQYWNrYWdlIH0gZnJvbSAnQHZlcmRhY2Npby90eXBlcyc7XG5pbXBvcnQgeyBJUHJveHksIFVwTGlua0NvbmZMb2NhbCB9IGZyb20gJy4uLy4uL3R5cGVzJztcbmltcG9ydCB7IHBhcnNlSW50ZXJ2YWwsIGlzT2JqZWN0LCBFcnJvckNvZGUsIGJ1aWxkVG9rZW4sIGlzT2JqZWN0T3JBcnJheSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnLi9sb2dnZXInO1xuaW1wb3J0IHsgRVJST1JfQ09ERSwgVE9LRU5fQkFTSUMsIFRPS0VOX0JFQVJFUiwgSEVBREVSUywgSFRUUF9TVEFUVVMsIEFQSV9FUlJPUiwgSEVBREVSX1RZUEUsIENIQVJBQ1RFUl9FTkNPRElORyB9IGZyb20gJy4vY29uc3RhbnRzJztcblxuY29uc3QgZGVidWcgPSBidWlsZERlYnVnKCd2ZXJkYWNjaW86dXAtc3RvcmFnZScpO1xuXG5jb25zdCBlbmNvZGUgPSBmdW5jdGlvbiAodGhpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHRoaW5nKS5yZXBsYWNlKC9eJTQwLywgJ0AnKTtcbn07XG5cbmNvbnN0IGpzb25Db250ZW50VHlwZSA9IEhFQURFUlMuSlNPTjtcbmNvbnN0IGNvbnRlbnRUeXBlQWNjZXB0ID0gYCR7anNvbkNvbnRlbnRUeXBlfTtgO1xuXG4vKipcbiAqIEp1c3QgYSBoZWxwZXIgKGBjb25maWdba2V5XSB8fCBkZWZhdWx0YCBkb2Vzbid0IHdvcmsgYmVjYXVzZSBvZiB6ZXJvZXMpXG4gKi9cbmNvbnN0IHNldENvbmZpZyA9IChjb25maWcsIGtleSwgZGVmKTogc3RyaW5nID0+IHtcbiAgcmV0dXJuIF8uaXNOaWwoY29uZmlnW2tleV0pID09PSBmYWxzZSA/IGNvbmZpZ1trZXldIDogZGVmO1xufTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIFN0b3JhZ2UgaW50ZXJmYWNlXG4gKiAoc2FtZSBmb3Igc3RvcmFnZS5qcywgbG9jYWwtc3RvcmFnZS5qcywgdXAtc3RvcmFnZS5qcylcbiAqL1xuY2xhc3MgUHJveHlTdG9yYWdlIGltcGxlbWVudHMgSVByb3h5IHtcbiAgcHVibGljIGNvbmZpZzogVXBMaW5rQ29uZkxvY2FsO1xuICBwdWJsaWMgZmFpbGVkX3JlcXVlc3RzOiBudW1iZXI7XG4gIHB1YmxpYyB1c2VyQWdlbnQ6IHN0cmluZztcbiAgcHVibGljIGNhOiBzdHJpbmcgfCB2b2lkO1xuICBwdWJsaWMgbG9nZ2VyOiBMb2dnZXI7XG4gIHB1YmxpYyBzZXJ2ZXJfaWQ6IHN0cmluZztcbiAgcHVibGljIHVybDogYW55O1xuICBwdWJsaWMgbWF4YWdlOiBudW1iZXI7XG4gIHB1YmxpYyB0aW1lb3V0OiBudW1iZXI7XG4gIHB1YmxpYyBtYXhfZmFpbHM6IG51bWJlcjtcbiAgcHVibGljIGZhaWxfdGltZW91dDogbnVtYmVyO1xuICBwdWJsaWMgYWdlbnRfb3B0aW9uczogYW55O1xuICAvLyBGSVhNRTogdXBuYW1lIGlzIGFzc2lnbmVkIHRvIGVhY2ggaW5zdGFuY2VcbiAgLy8gQHRzLWlnbm9yZVxuICBwdWJsaWMgdXBuYW1lOiBzdHJpbmc7XG4gIC8vIEZJWE1FOiBwcm94eSBjYW4gYmUgYm9vbGVhbiBvciBvYmplY3QsIHNvbWV0aGluZyBzbWVsbHMgaGVyZVxuICAvLyBAdHMtaWdub3JlXG4gIHB1YmxpYyBwcm94eTogc3RyaW5nIHwgdm9pZDtcbiAgLy8gQHRzLWlnbm9yZVxuICBwdWJsaWMgbGFzdF9yZXF1ZXN0X3RpbWU6IG51bWJlciB8IG51bGw7XG4gIHB1YmxpYyBzdHJpY3Rfc3NsOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0geyp9IGNvbmZpZ1xuICAgKiBAcGFyYW0geyp9IG1haW5Db25maWdcbiAgICovXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcihjb25maWc6IFVwTGlua0NvbmZMb2NhbCwgbWFpbkNvbmZpZzogQ29uZmlnKSB7XG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XG4gICAgdGhpcy5mYWlsZWRfcmVxdWVzdHMgPSAwO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLnVzZXJBZ2VudCA9IG1haW5Db25maWcudXNlcl9hZ2VudDtcbiAgICB0aGlzLmNhID0gY29uZmlnLmNhO1xuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuc2VydmVyX2lkID0gbWFpbkNvbmZpZy5zZXJ2ZXJfaWQ7XG5cbiAgICB0aGlzLnVybCA9IFVSTC5wYXJzZSh0aGlzLmNvbmZpZy51cmwpO1xuICAgIC8vICRGbG93Rml4TWVcbiAgICB0aGlzLl9zZXR1cFByb3h5KHRoaXMudXJsLmhvc3RuYW1lLCBjb25maWcsIG1haW5Db25maWcsIHRoaXMudXJsLnByb3RvY29sID09PSAnaHR0cHM6Jyk7XG5cbiAgICB0aGlzLmNvbmZpZy51cmwgPSB0aGlzLmNvbmZpZy51cmwucmVwbGFjZSgvXFwvJC8sICcnKTtcblxuICAgIGlmICh0aGlzLmNvbmZpZy50aW1lb3V0ICYmIE51bWJlcih0aGlzLmNvbmZpZy50aW1lb3V0KSA+PSAxMDAwKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFxuICAgICAgICBbXG4gICAgICAgICAgJ1RvbyBiaWcgdGltZW91dCB2YWx1ZTogJyArIHRoaXMuY29uZmlnLnRpbWVvdXQsXG4gICAgICAgICAgJ1dlIGNoYW5nZWQgdGltZSBmb3JtYXQgdG8gbmdpbngtbGlrZSBvbmUnLFxuICAgICAgICAgICcoc2VlIGh0dHA6Ly9uZ2lueC5vcmcvZW4vZG9jcy9zeW50YXguaHRtbCknLFxuICAgICAgICAgICdzbyBwbGVhc2UgdXBkYXRlIHlvdXIgY29uZmlnIGFjY29yZGluZ2x5JyxcbiAgICAgICAgXS5qb2luKCdcXG4nKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBhIGJ1bmNoIG9mIGRpZmZlcmVudCBjb25maWd1cmFibGUgdGltZXJzXG4gICAgdGhpcy5tYXhhZ2UgPSBwYXJzZUludGVydmFsKHNldENvbmZpZyh0aGlzLmNvbmZpZywgJ21heGFnZScsICcybScpKTtcbiAgICB0aGlzLnRpbWVvdXQgPSBwYXJzZUludGVydmFsKHNldENvbmZpZyh0aGlzLmNvbmZpZywgJ3RpbWVvdXQnLCAnMzBzJykpO1xuICAgIHRoaXMubWF4X2ZhaWxzID0gTnVtYmVyKHNldENvbmZpZyh0aGlzLmNvbmZpZywgJ21heF9mYWlscycsIDIpKTtcbiAgICB0aGlzLmZhaWxfdGltZW91dCA9IHBhcnNlSW50ZXJ2YWwoc2V0Q29uZmlnKHRoaXMuY29uZmlnLCAnZmFpbF90aW1lb3V0JywgJzVtJykpO1xuICAgIHRoaXMuc3RyaWN0X3NzbCA9IEJvb2xlYW4oc2V0Q29uZmlnKHRoaXMuY29uZmlnLCAnc3RyaWN0X3NzbCcsIHRydWUpKTtcbiAgICB0aGlzLmFnZW50X29wdGlvbnMgPSBzZXRDb25maWcodGhpcy5jb25maWcsICdhZ2VudF9vcHRpb25zJywge1xuICAgICAga2VlcEFsaXZlOiB0cnVlLFxuICAgICAgbWF4U29ja2V0czogNDAsXG4gICAgICBtYXhGcmVlU29ja2V0czogMTAsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYW4gYXNzZXQuXG4gICAqIEBwYXJhbSB7Kn0gb3B0aW9uc1xuICAgKiBAcGFyYW0geyp9IGNiXG4gICAqIEByZXR1cm4ge1JlcXVlc3R9XG4gICAqL1xuICBwcml2YXRlIHJlcXVlc3Qob3B0aW9uczogYW55LCBjYj86IENhbGxiYWNrKTogU3RyZWFtLlJlYWRhYmxlIHtcbiAgICBsZXQganNvbjtcblxuICAgIGlmICh0aGlzLl9zdGF0dXNDaGVjaygpID09PSBmYWxzZSkge1xuICAgICAgY29uc3Qgc3RyZWFtUmVhZCA9IG5ldyBTdHJlYW0uUmVhZGFibGUoKTtcblxuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKTogdm9pZCB7XG4gICAgICAgIGlmIChjYikge1xuICAgICAgICAgIGNiKEVycm9yQ29kZS5nZXRJbnRlcm5hbEVycm9yKEFQSV9FUlJPUi5VUExJTktfT0ZGTElORSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbVJlYWQuZW1pdCgnZXJyb3InLCBFcnJvckNvZGUuZ2V0SW50ZXJuYWxFcnJvcihBUElfRVJST1IuVVBMSU5LX09GRkxJTkUpKTtcbiAgICAgIH0pO1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgc3RyZWFtUmVhZC5fcmVhZCA9IGZ1bmN0aW9uICgpOiB2b2lkIHt9O1xuICAgICAgLy8gcHJldmVudGluZyAnVW5jYXVnaHQsIHVuc3BlY2lmaWVkIFwiZXJyb3JcIiBldmVudCdcbiAgICAgIHN0cmVhbVJlYWQub24oJ2Vycm9yJywgZnVuY3Rpb24gKCk6IHZvaWQge30pO1xuICAgICAgcmV0dXJuIHN0cmVhbVJlYWQ7XG4gICAgfVxuXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgY29uc3QgaGVhZGVyczogSGVhZGVycyA9IHRoaXMuX3NldEhlYWRlcnMob3B0aW9ucyk7XG5cbiAgICB0aGlzLl9hZGRQcm94eUhlYWRlcnMob3B0aW9ucy5yZXEsIGhlYWRlcnMpO1xuICAgIHRoaXMuX292ZXJyaWRlV2l0aFVwTGlua0NvbmZMb2NhbGlnSGVhZGVycyhoZWFkZXJzKTtcblxuICAgIGNvbnN0IG1ldGhvZCA9IG9wdGlvbnMubWV0aG9kIHx8ICdHRVQnO1xuICAgIGNvbnN0IHVyaSA9IG9wdGlvbnMudXJpX2Z1bGwgfHwgdGhpcy5jb25maWcudXJsICsgb3B0aW9ucy51cmk7XG5cbiAgICBzZWxmLmxvZ2dlci5pbmZvKFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgdXJpOiB1cmksXG4gICAgICB9LFxuICAgICAgXCJtYWtpbmcgcmVxdWVzdDogJ0B7bWV0aG9kfSBAe3VyaX0nXCJcbiAgICApO1xuXG4gICAgaWYgKGlzT2JqZWN0KG9wdGlvbnMuanNvbikpIHtcbiAgICAgIGpzb24gPSBKU09OLnN0cmluZ2lmeShvcHRpb25zLmpzb24pO1xuICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSBoZWFkZXJzWydDb250ZW50LVR5cGUnXSB8fCBIRUFERVJTLkpTT047XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdENhbGxiYWNrID0gY2JcbiAgICAgID8gZnVuY3Rpb24gKGVyciwgcmVzLCBib2R5KTogdm9pZCB7XG4gICAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlTGVuZ3RoID0gZXJyID8gMCA6IGJvZHkubGVuZ3RoO1xuICAgICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgICBwcm9jZXNzQm9keSgpO1xuICAgICAgICAgIGxvZ0FjdGl2aXR5KCk7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICAgIGNiKGVyciwgcmVzLCBib2R5KTtcblxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFBlcmZvcm0gYSBkZWNvZGUuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gcHJvY2Vzc0JvZHkoKTogdm9pZCB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIGVycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuanNvbiAmJiByZXMuc3RhdHVzQ29kZSA8IDMwMCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5LnRvU3RyaW5nKENIQVJBQ1RFUl9FTkNPRElORy5VVEY4KSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgICAgICBib2R5ID0ge307XG4gICAgICAgICAgICAgICAgZXJyID0gX2VycjtcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVyci5tZXNzYWdlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZXJyICYmIGlzT2JqZWN0KGJvZHkpKSB7XG4gICAgICAgICAgICAgIGlmIChfLmlzU3RyaW5nKGJvZHkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBib2R5LmVycm9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFBlcmZvcm0gYSBsb2cuXG4gICAgICAgICAgICovXG4gICAgICAgICAgZnVuY3Rpb24gbG9nQWN0aXZpdHkoKTogdm9pZCB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZSA9IFwiQHshc3RhdHVzfSwgcmVxOiAnQHtyZXF1ZXN0Lm1ldGhvZH0gQHtyZXF1ZXN0LnVybH0nXCI7XG4gICAgICAgICAgICBtZXNzYWdlICs9IGVycm9yID8gJywgZXJyb3I6IEB7IWVycm9yfScgOiAnLCBieXRlczogQHtieXRlcy5pbn0vQHtieXRlcy5vdXR9JztcbiAgICAgICAgICAgIHNlbGYubG9nZ2VyLmh0dHAoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlcnI6IGVyciB8fCB1bmRlZmluZWQsIC8vIGlmIGVycm9yIGlzIG51bGwvZmFsc2UgY2hhbmdlIHRoaXMgdG8gdW5kZWZpbmVkIHNvIGl0IHdvbnQgbG9nXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgdXJsOiB1cmkgfSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6IHJlcyAhPSBudWxsID8gcmVzLnN0YXR1c0NvZGUgOiAnRVJSJyxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgYnl0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIGluOiBqc29uID8ganNvbi5sZW5ndGggOiAwLFxuICAgICAgICAgICAgICAgICAgb3V0OiByZXNwb25zZUxlbmd0aCB8fCAwLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICA6IHVuZGVmaW5lZDtcblxuICAgIGxldCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgIHVybDogdXJpLFxuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgYm9keToganNvbixcbiAgICAgIHByb3h5OiB0aGlzLnByb3h5LFxuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBnemlwOiB0cnVlLFxuICAgICAgdGltZW91dDogdGhpcy50aW1lb3V0LFxuICAgICAgc3RyaWN0U1NMOiB0aGlzLnN0cmljdF9zc2wsXG4gICAgICBhZ2VudE9wdGlvbnM6IHRoaXMuYWdlbnRfb3B0aW9ucyxcbiAgICB9O1xuXG4gICAgaWYgKHRoaXMuY2EpIHtcbiAgICAgIHJlcXVlc3RPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdE9wdGlvbnMsIHtcbiAgICAgICAgY2E6IHRoaXMuY2EsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCByZXEgPSByZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCByZXF1ZXN0Q2FsbGJhY2spO1xuXG4gICAgbGV0IHN0YXR1c0NhbGxlZCA9IGZhbHNlO1xuICAgIHJlcS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzKTogdm9pZCB7XG4gICAgICAvLyBGSVhNRTogX3ZlcmRhY2Npb19hYm9ydGVkIHNlZW1zIG5vdCB1c2VkXG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBpZiAoIXJlcS5fdmVyZGFjY2lvX2Fib3J0ZWQgJiYgIXN0YXR1c0NhbGxlZCkge1xuICAgICAgICBzdGF0dXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICBzZWxmLl9zdGF0dXNDaGVjayh0cnVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF8uaXNOaWwocmVxdWVzdENhbGxiYWNrKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgKGZ1bmN0aW9uIGRvX2xvZygpOiB2b2lkIHtcbiAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJAeyFzdGF0dXN9LCByZXE6ICdAe3JlcXVlc3QubWV0aG9kfSBAe3JlcXVlc3QudXJsfScgKHN0cmVhbWluZylcIjtcbiAgICAgICAgICBzZWxmLmxvZ2dlci5odHRwKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXF1ZXN0OiB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmksXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHN0YXR1czogXy5pc051bGwocmVzKSA9PT0gZmFsc2UgPyByZXMuc3RhdHVzQ29kZSA6ICdFUlInLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICApO1xuICAgICAgICB9KSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJlcS5vbignZXJyb3InLCBmdW5jdGlvbiAoX2Vycik6IHZvaWQge1xuICAgICAgLy8gRklYTUU6IF92ZXJkYWNjaW9fYWJvcnRlZCBzZWVtcyBub3QgdXNlZFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgaWYgKCFyZXEuX3ZlcmRhY2Npb19hYm9ydGVkICYmICFzdGF0dXNDYWxsZWQpIHtcbiAgICAgICAgc3RhdHVzQ2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5fc3RhdHVzQ2hlY2soZmFsc2UpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gcmVxO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBkZWZhdWx0IGhlYWRlcnMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgX3NldEhlYWRlcnMob3B0aW9uczogYW55KTogSGVhZGVycyB7XG4gICAgY29uc3QgaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICBjb25zdCBhY2NlcHQgPSBIRUFERVJTLkFDQ0VQVDtcbiAgICBjb25zdCBhY2NlcHRFbmNvZGluZyA9IEhFQURFUlMuQUNDRVBUX0VOQ09ESU5HO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IEhFQURFUlMuVVNFUl9BR0VOVDtcblxuICAgIGhlYWRlcnNbYWNjZXB0XSA9IGhlYWRlcnNbYWNjZXB0XSB8fCBjb250ZW50VHlwZUFjY2VwdDtcbiAgICBoZWFkZXJzW2FjY2VwdEVuY29kaW5nXSA9IGhlYWRlcnNbYWNjZXB0RW5jb2RpbmddIHx8ICdnemlwJztcbiAgICAvLyByZWdpc3RyeS5ucG1qcy5vcmcgd2lsbCBvbmx5IHJldHVybiBzZWFyY2ggcmVzdWx0IGlmIHVzZXItYWdlbnQgaW5jbHVkZSBzdHJpbmcgJ25wbSdcbiAgICBoZWFkZXJzW3VzZXJBZ2VudF0gPSB0aGlzLnVzZXJBZ2VudCA/IGBucG0gKCR7dGhpcy51c2VyQWdlbnR9KWAgOiBvcHRpb25zLnJlcT8uZ2V0KCd1c2VyLWFnZW50Jyk7XG5cbiAgICByZXR1cm4gdGhpcy5fc2V0QXV0aChoZWFkZXJzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBjb25maWd1cmF0aW9uIGF1dGggYW5kIGFzc2lnbiBIZWFkZXIgYXV0aG9yaXphdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9zZXRBdXRoKGhlYWRlcnM6IGFueSk6IEhlYWRlcnMge1xuICAgIGNvbnN0IHsgYXV0aCB9ID0gdGhpcy5jb25maWc7XG5cbiAgICBpZiAoXy5pc05pbChhdXRoKSB8fCBoZWFkZXJzW0hFQURFUlMuQVVUSE9SSVpBVElPTl0pIHtcbiAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cblxuICAgIGlmIChfLmlzT2JqZWN0KGF1dGgpID09PSBmYWxzZSAmJiBfLmlzT2JqZWN0KGF1dGgudG9rZW4pID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5fdGhyb3dFcnJvckF1dGgoJ0F1dGggaW52YWxpZCcpO1xuICAgIH1cblxuICAgIC8vIGdldCBOUE1fVE9LRU4gaHR0cDovL2Jsb2cubnBtanMub3JnL3Bvc3QvMTE4MzkzMzY4NTU1L2RlcGxveWluZy13aXRoLW5wbS1wcml2YXRlLW1vZHVsZXNcbiAgICAvLyBvciBnZXQgb3RoZXIgdmFyaWFibGUgZXhwb3J0IGluIGVudlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJkYWNjaW8vdmVyZGFjY2lvL3JlbGVhc2VzL3RhZy92Mi41LjBcbiAgICBsZXQgdG9rZW46IGFueTtcbiAgICBjb25zdCB0b2tlbkNvbmY6IGFueSA9IGF1dGg7XG5cbiAgICBpZiAoXy5pc05pbCh0b2tlbkNvbmYudG9rZW4pID09PSBmYWxzZSAmJiBfLmlzU3RyaW5nKHRva2VuQ29uZi50b2tlbikpIHtcbiAgICAgIHRva2VuID0gdG9rZW5Db25mLnRva2VuO1xuICAgIH0gZWxzZSBpZiAoXy5pc05pbCh0b2tlbkNvbmYudG9rZW5fZW52KSA9PT0gZmFsc2UpIHtcbiAgICAgIGlmIChfLmlzU3RyaW5nKHRva2VuQ29uZi50b2tlbl9lbnYpKSB7XG4gICAgICAgIHRva2VuID0gcHJvY2Vzcy5lbnZbdG9rZW5Db25mLnRva2VuX2Vudl07XG4gICAgICB9IGVsc2UgaWYgKF8uaXNCb29sZWFuKHRva2VuQ29uZi50b2tlbl9lbnYpICYmIHRva2VuQ29uZi50b2tlbl9lbnYpIHtcbiAgICAgICAgdG9rZW4gPSBwcm9jZXNzLmVudi5OUE1fVE9LRU47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZ2dlci5lcnJvcihFUlJPUl9DT0RFLnRva2VuX3JlcXVpcmVkKTtcbiAgICAgICAgdGhpcy5fdGhyb3dFcnJvckF1dGgoRVJST1JfQ09ERS50b2tlbl9yZXF1aXJlZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRva2VuID0gcHJvY2Vzcy5lbnYuTlBNX1RPS0VOO1xuICAgIH1cblxuICAgIGlmIChfLmlzTmlsKHRva2VuKSkge1xuICAgICAgdGhpcy5fdGhyb3dFcnJvckF1dGgoRVJST1JfQ09ERS50b2tlbl9yZXF1aXJlZCk7XG4gICAgfVxuXG4gICAgLy8gZGVmaW5lIHR5cGUgQXV0aCBhbGxvdyBiYXNpYyBhbmQgYmVhcmVyXG4gICAgY29uc3QgdHlwZSA9IHRva2VuQ29uZi50eXBlIHx8IFRPS0VOX0JBU0lDO1xuICAgIHRoaXMuX3NldEhlYWRlckF1dGhvcml6YXRpb24oaGVhZGVycywgdHlwZSwgdG9rZW4pO1xuXG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAgICogQHRocm93cyB7RXJyb3J9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF90aHJvd0Vycm9yQXV0aChtZXNzYWdlOiBzdHJpbmcpOiBFcnJvciB7XG4gICAgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbiBIZWFkZXIgYXV0aG9yaXphdGlvbiB3aXRoIHR5cGUgYXV0aGVudGljYXRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBwcml2YXRlIF9zZXRIZWFkZXJBdXRob3JpemF0aW9uKGhlYWRlcnM6IGFueSwgdHlwZTogc3RyaW5nLCB0b2tlbjogYW55KTogdm9pZCB7XG4gICAgY29uc3QgX3R5cGU6IHN0cmluZyA9IHR5cGUudG9Mb3dlckNhc2UoKTtcblxuICAgIGlmIChfdHlwZSAhPT0gVE9LRU5fQkVBUkVSLnRvTG93ZXJDYXNlKCkgJiYgX3R5cGUgIT09IFRPS0VOX0JBU0lDLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIHRoaXMuX3Rocm93RXJyb3JBdXRoKGBBdXRoIHR5cGUgJyR7X3R5cGV9JyBub3QgYWxsb3dlZGApO1xuICAgIH1cblxuICAgIHR5cGUgPSBfLnVwcGVyRmlyc3QodHlwZSk7XG4gICAgaGVhZGVyc1tIRUFERVJTLkFVVEhPUklaQVRJT05dID0gYnVpbGRUb2tlbih0eXBlLCB0b2tlbik7XG4gIH1cblxuICAvKipcbiAgICogSXQgd2lsbCBhZGQgb3Igb3ZlcnJpZGUgc3BlY2lmaWVkIGhlYWRlcnMgZnJvbSBjb25maWcgZmlsZS5cbiAgICpcbiAgICogRWc6XG4gICAqXG4gICAqIHVwbGlua3M6XG4gICBucG1qczpcbiAgIHVybDogaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvXG4gICBoZWFkZXJzOlxuICAgQWNjZXB0OiBcImFwcGxpY2F0aW9uL3ZuZC5ucG0uaW5zdGFsbC12Mitqc29uOyBxPTEuMFwiXG4gICB2ZXJkYWNjaW8tc3RhZ2luZzpcbiAgIHVybDogaHR0cHM6Ly9teWNvbXBhbnkuY29tL25wbVxuICAgaGVhZGVyczpcbiAgIEFjY2VwdDogXCJhcHBsaWNhdGlvbi9qc29uXCJcbiAgIGF1dGhvcml6YXRpb246IFwiQmFzaWMgWW91ckJhc2U2NEVuY29kZWRDcmVkZW50aWFscz09XCJcblxuICAgKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfb3ZlcnJpZGVXaXRoVXBMaW5rQ29uZkxvY2FsaWdIZWFkZXJzKGhlYWRlcnM6IEhlYWRlcnMpOiBhbnkge1xuICAgIGlmICghdGhpcy5jb25maWcuaGVhZGVycykge1xuICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG4gICAgLy8gYWRkL292ZXJyaWRlIGhlYWRlcnMgc3BlY2lmaWVkIGluIHRoZSBjb25maWdcbiAgICAvKiBlc2xpbnQgZ3VhcmQtZm9yLWluOiAwICovXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5jb25maWcuaGVhZGVycykge1xuICAgICAgaGVhZGVyc1trZXldID0gdGhpcy5jb25maWcuaGVhZGVyc1trZXldO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgd2hldGhlciBjYW4gZmV0Y2ggZnJvbSB0aGUgcHJvdmlkZWQgVVJMXG4gICAqIEBwYXJhbSB7Kn0gdXJsXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBwdWJsaWMgaXNVcGxpbmtWYWxpZCh1cmw6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vICRGbG93Rml4TWVcbiAgICBjb25zdCB1cmxQYXJzZWQ6IFVybFdpdGhTdHJpbmdRdWVyeSA9IFVSTC5wYXJzZSh1cmwpO1xuICAgIGNvbnN0IGlzSFRUUFMgPSAodXJsRG9tYWluUGFyc2VkOiBVUkwpOiBib29sZWFuID0+IHVybERvbWFpblBhcnNlZC5wcm90b2NvbCA9PT0gJ2h0dHBzOicgJiYgKHVybFBhcnNlZC5wb3J0ID09PSBudWxsIHx8IHVybFBhcnNlZC5wb3J0ID09PSAnNDQzJyk7XG4gICAgY29uc3QgZ2V0SG9zdCA9ICh1cmxEb21haW5QYXJzZWQpOiBib29sZWFuID0+IChpc0hUVFBTKHVybERvbWFpblBhcnNlZCkgPyB1cmxEb21haW5QYXJzZWQuaG9zdG5hbWUgOiB1cmxEb21haW5QYXJzZWQuaG9zdCk7XG4gICAgY29uc3QgaXNNYXRjaFByb3RvY29sOiBib29sZWFuID0gdXJsUGFyc2VkLnByb3RvY29sID09PSB0aGlzLnVybC5wcm90b2NvbDtcbiAgICBjb25zdCBpc01hdGNoSG9zdDogYm9vbGVhbiA9IGdldEhvc3QodXJsUGFyc2VkKSA9PT0gZ2V0SG9zdCh0aGlzLnVybCk7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IGlzTWF0Y2hQYXRoOiBib29sZWFuID0gdXJsUGFyc2VkLnBhdGguaW5kZXhPZih0aGlzLnVybC5wYXRoKSA9PT0gMDtcblxuICAgIHJldHVybiBpc01hdGNoUHJvdG9jb2wgJiYgaXNNYXRjaEhvc3QgJiYgaXNNYXRjaFBhdGg7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGEgcmVtb3RlIHBhY2thZ2UgbWV0YWRhdGFcbiAgICogQHBhcmFtIHsqfSBuYW1lIHBhY2thZ2UgbmFtZVxuICAgKiBAcGFyYW0geyp9IG9wdGlvbnMgcmVxdWVzdCBvcHRpb25zLCBlZzogZVRhZy5cbiAgICogQHBhcmFtIHsqfSBjYWxsYmFja1xuICAgKi9cbiAgcHVibGljIGdldFJlbW90ZU1ldGFkYXRhKG5hbWU6IHN0cmluZywgb3B0aW9uczogYW55LCBjYWxsYmFjazogQ2FsbGJhY2spOiB2b2lkIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKF8uaXNOaWwob3B0aW9ucy5ldGFnKSA9PT0gZmFsc2UpIHtcbiAgICAgIGhlYWRlcnNbJ0lmLU5vbmUtTWF0Y2gnXSA9IG9wdGlvbnMuZXRhZztcbiAgICAgIGhlYWRlcnNbSEVBREVSUy5BQ0NFUFRdID0gY29udGVudFR5cGVBY2NlcHQ7XG4gICAgfVxuXG4gICAgdGhpcy5yZXF1ZXN0KFxuICAgICAge1xuICAgICAgICB1cmk6IGAvJHtlbmNvZGUobmFtZSl9YCxcbiAgICAgICAganNvbjogdHJ1ZSxcbiAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgcmVxOiBvcHRpb25zLnJlcSxcbiAgICAgIH0sXG4gICAgICAoZXJyLCByZXMsIGJvZHkpOiB2b2lkID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVycm9yQ29kZS5nZXROb3RGb3VuZChBUElfRVJST1IuTk9UX1BBQ0tBR0VfVVBMSU5LKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEocmVzLnN0YXR1c0NvZGUgPj0gSFRUUF9TVEFUVVMuT0sgJiYgcmVzLnN0YXR1c0NvZGUgPCBIVFRQX1NUQVRVUy5NVUxUSVBMRV9DSE9JQ0VTKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoYCR7QVBJX0VSUk9SLkJBRF9TVEFUVVNfQ09ERX06ICR7cmVzLnN0YXR1c0NvZGV9YCk7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgICAgIGVycm9yLnJlbW90ZVN0YXR1cyA9IHJlcy5zdGF0dXNDb2RlO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgYm9keSwgcmVzLmhlYWRlcnMuZXRhZyk7XG4gICAgICB9XG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIHRhcmJhbGwgZnJvbSB0aGUgdXBsaW5rLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gICAqIEByZXR1cm4ge1N0cmVhbX1cbiAgICovXG4gIGZldGNoVGFyYmFsbCh1cmw6IHN0cmluZykge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBSZWFkVGFyYmFsbCh7fSk7XG4gICAgbGV0IGN1cnJlbnRfbGVuZ3RoID0gMDtcbiAgICBsZXQgZXhwZWN0ZWRfbGVuZ3RoO1xuXG4gICAgc3RyZWFtLmFib3J0ID0gKCkgPT4ge307XG4gICAgY29uc3QgcmVhZFN0cmVhbSA9IHRoaXMucmVxdWVzdCh7XG4gICAgICB1cmlfZnVsbDogdXJsLFxuICAgICAgZW5jb2Rpbmc6IG51bGwsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEFjY2VwdDogY29udGVudFR5cGVBY2NlcHQsXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgcmVhZFN0cmVhbS5vbigncmVzcG9uc2UnLCBmdW5jdGlvbiAocmVzOiBhbnkpIHtcbiAgICAgIGlmIChyZXMuc3RhdHVzQ29kZSA9PT0gSFRUUF9TVEFUVVMuTk9UX0ZPVU5EKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBFcnJvckNvZGUuZ2V0Tm90Rm91bmQoQVBJX0VSUk9SLk5PVF9GSUxFX1VQTElOSykpO1xuICAgICAgfVxuICAgICAgaWYgKCEocmVzLnN0YXR1c0NvZGUgPj0gSFRUUF9TVEFUVVMuT0sgJiYgcmVzLnN0YXR1c0NvZGUgPCBIVFRQX1NUQVRVUy5NVUxUSVBMRV9DSE9JQ0VTKSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoYGJhZCB1cGxpbmsgc3RhdHVzIGNvZGU6ICR7cmVzLnN0YXR1c0NvZGV9YCkpO1xuICAgICAgfVxuICAgICAgaWYgKHJlcy5oZWFkZXJzW0hFQURFUl9UWVBFLkNPTlRFTlRfTEVOR1RIXSkge1xuICAgICAgICBleHBlY3RlZF9sZW5ndGggPSByZXMuaGVhZGVyc1tIRUFERVJfVFlQRS5DT05URU5UX0xFTkdUSF07XG4gICAgICAgIHN0cmVhbS5lbWl0KEhFQURFUl9UWVBFLkNPTlRFTlRfTEVOR1RILCByZXMuaGVhZGVyc1tIRUFERVJfVFlQRS5DT05URU5UX0xFTkdUSF0pO1xuICAgICAgfVxuXG4gICAgICByZWFkU3RyZWFtLnBpcGUoc3RyZWFtKTtcbiAgICB9KTtcblxuICAgIHJlYWRTdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9KTtcbiAgICByZWFkU3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGN1cnJlbnRfbGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJlYWRTdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBjdXJyZW50X2xlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlY3RlZF9sZW5ndGggJiYgY3VycmVudF9sZW5ndGggIT0gZXhwZWN0ZWRfbGVuZ3RoKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIEVycm9yQ29kZS5nZXRJbnRlcm5hbEVycm9yKEFQSV9FUlJPUi5DT05URU5UX01JU01BVENIKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtIGEgc3RyZWFtIHNlYXJjaC5cbiAgICogQHBhcmFtIHsqfSBvcHRpb25zIHJlcXVlc3Qgb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtTdHJlYW19XG4gICAqL1xuICBwdWJsaWMgc2VhcmNoKG9wdGlvbnM6IGFueSk6IFN0cmVhbS5SZWFkYWJsZSB7XG4gICAgY29uc3QgdHJhbnNmb3JtU3RyZWFtOiBhbnkgPSBuZXcgU3RyZWFtLlBhc3NUaHJvdWdoKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICBjb25zdCByZXF1ZXN0U3RyZWFtOiBTdHJlYW0uUmVhZGFibGUgPSB0aGlzLnJlcXVlc3Qoe1xuICAgICAgdXJpOiBvcHRpb25zLnJlcS51cmwsXG4gICAgICByZXE6IG9wdGlvbnMucmVxLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAvLyBxdWVyeSBmb3Igc2VhcmNoXG4gICAgICAgIHJlZmVyZXI6IG9wdGlvbnMucmVxLmdldCgncmVmZXJlcicpLFxuICAgICAgfSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHBhcnNlUGFja2FnZSA9IChwa2c6IFBhY2thZ2UpOiB2b2lkID0+IHtcbiAgICAgIGlmIChpc09iamVjdE9yQXJyYXkocGtnKSkge1xuICAgICAgICB0cmFuc2Zvcm1TdHJlYW0uZW1pdCgnZGF0YScsIHBrZyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJlcXVlc3RTdHJlYW0ub24oJ3Jlc3BvbnNlJywgKHJlcyk6IHZvaWQgPT4ge1xuICAgICAgaWYgKCFTdHJpbmcocmVzLnN0YXR1c0NvZGUpLm1hdGNoKC9eMlxcZFxcZCQvKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNmb3JtU3RyZWFtLmVtaXQoJ2Vycm9yJywgRXJyb3JDb2RlLmdldEludGVybmFsRXJyb3IoYGJhZCBzdGF0dXMgY29kZSAke3Jlcy5zdGF0dXNDb2RlfSBmcm9tIHVwbGlua2ApKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9yZXF1ZXN0L3JlcXVlc3QjcmVxdWVzdG9wdGlvbnMtY2FsbGJhY2tcbiAgICAgIC8vIFJlcXVlc3QgbGlicmFyeSB3aWxsIG5vdCBkZWNvZGUgZ3ppcCBzdHJlYW0uXG4gICAgICBsZXQganNvblN0cmVhbTtcbiAgICAgIGlmIChyZXMuaGVhZGVyc1tIRUFERVJfVFlQRS5DT05URU5UX0VOQ09ESU5HXSA9PT0gSEVBREVSUy5HWklQKSB7XG4gICAgICAgIGpzb25TdHJlYW0gPSByZXMucGlwZSh6bGliLmNyZWF0ZVVuemlwKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAganNvblN0cmVhbSA9IHJlcztcbiAgICAgIH1cbiAgICAgIGpzb25TdHJlYW0ucGlwZShKU09OU3RyZWFtLnBhcnNlKCcqJykpLm9uKCdkYXRhJywgcGFyc2VQYWNrYWdlKTtcbiAgICAgIGpzb25TdHJlYW0ub24oJ2VuZCcsICgpOiB2b2lkID0+IHtcbiAgICAgICAgdHJhbnNmb3JtU3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXF1ZXN0U3RyZWFtLm9uKCdlcnJvcicsIChlcnI6IEVycm9yKTogdm9pZCA9PiB7XG4gICAgICB0cmFuc2Zvcm1TdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH0pO1xuXG4gICAgdHJhbnNmb3JtU3RyZWFtLmFib3J0ID0gKCk6IHZvaWQgPT4ge1xuICAgICAgLy8gRklYTUU6IHRoaXMgaXMgY2xlYXJseSBhIHBvdGVudGlhbCBpc3N1ZVxuICAgICAgLy8gdGhlcmUgaXMgbm8gYWJvcnQgbWV0aG9kIG9uIFN0cmVhbS5SZWFkYWJsZVxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgcmVxdWVzdFN0cmVhbS5hYm9ydCgpO1xuICAgICAgdHJhbnNmb3JtU3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgIH07XG5cbiAgICByZXR1cm4gdHJhbnNmb3JtU3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBwcm94eSBoZWFkZXJzLlxuICAgKiBGSVhNRTogb2JqZWN0IG11dGF0aW9ucywgaXQgc2hvdWxkIHJldHVybiBhbiBuZXcgb2JqZWN0XG4gICAqIEBwYXJhbSB7Kn0gcmVxIHRoZSBodHRwIHJlcXVlc3RcbiAgICogQHBhcmFtIHsqfSBoZWFkZXJzIHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICovXG4gIHByaXZhdGUgX2FkZFByb3h5SGVhZGVycyhyZXE6IGFueSwgaGVhZGVyczogYW55KTogdm9pZCB7XG4gICAgaWYgKHJlcSkge1xuICAgICAgLy8gT25seSBzdWJtaXQgWC1Gb3J3YXJkZWQtRm9yIGZpZWxkIGlmIHdlIGRvbid0IGhhdmUgYSBwcm94eSBzZWxlY3RlZFxuICAgICAgLy8gaW4gdGhlIGNvbmZpZyBmaWxlLlxuICAgICAgLy9cbiAgICAgIC8vIE90aGVyd2lzZSBtaXNjb25maWd1cmVkIHByb3h5IGNvdWxkIHJldHVybiA0MDc6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcmxpZHdrYS9zaW5vcGlhL2lzc3Vlcy8yNTRcbiAgICAgIC8vXG4gICAgICAvLyBGSVhNRTogcHJveHkgbG9naWMgaXMgb2RkLCBzb21ldGhpbmcgaXMgd3JvbmcgaGVyZS5cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICghdGhpcy5wcm94eSkge1xuICAgICAgICBoZWFkZXJzWyd4LWZvcndhcmRlZC1mb3InXSA9IChyZXEuZ2V0KCd4LWZvcndhcmRlZC1mb3InKSA/IHJlcS5nZXQoJ3gtZm9yd2FyZGVkLWZvcicpICsgJywgJyA6ICcnKSArIHJlcS5jb25uZWN0aW9uLnJlbW90ZUFkZHJlc3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gYWx3YXlzIGF0dGFjaCBWaWEgaGVhZGVyIHRvIGF2b2lkIGxvb3BzLCBldmVuIGlmIHdlJ3JlIG5vdCBwcm94eWluZ1xuICAgIGhlYWRlcnNbJ3ZpYSddID0gcmVxICYmIHJlcS5nZXQoJ3ZpYScpID8gcmVxLmdldCgndmlhJykgKyAnLCAnIDogJyc7XG5cbiAgICBoZWFkZXJzWyd2aWEnXSArPSAnMS4xICcgKyB0aGlzLnNlcnZlcl9pZCArICcgKFZlcmRhY2NpbyknO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHdoZXRoZXIgdGhlIHJlbW90ZSBob3N0IGlzIGF2YWlsYWJsZS5cbiAgICogQHBhcmFtIHsqfSBhbGl2ZVxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgcHJpdmF0ZSBfc3RhdHVzQ2hlY2soYWxpdmU/OiBib29sZWFuKTogYm9vbGVhbiB8IHZvaWQge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5faWZSZXF1ZXN0RmFpbHVyZSgpID09PSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGFsaXZlKSB7XG4gICAgICBpZiAodGhpcy5mYWlsZWRfcmVxdWVzdHMgPj0gdGhpcy5tYXhfZmFpbHMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBob3N0OiB0aGlzLnVybC5ob3N0LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2hvc3QgQHtob3N0fSBpcyBiYWNrIG9ubGluZSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmFpbGVkX3JlcXVlc3RzID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5mYWlsZWRfcmVxdWVzdHMrKztcbiAgICAgIGlmICh0aGlzLmZhaWxlZF9yZXF1ZXN0cyA9PT0gdGhpcy5tYXhfZmFpbHMpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcbiAgICAgICAgICB7XG4gICAgICAgICAgICBob3N0OiB0aGlzLnVybC5ob3N0LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2hvc3QgQHtob3N0fSBpcyBub3cgb2ZmbGluZSdcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxhc3RfcmVxdWVzdF90aW1lID0gRGF0ZS5ub3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0aGUgcmVxdWVzdCBmYWlsdXJlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgcHJpdmF0ZSBfaWZSZXF1ZXN0RmFpbHVyZSgpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5mYWlsZWRfcmVxdWVzdHMgPj0gdGhpcy5tYXhfZmFpbHMgJiYgTWF0aC5hYnMoRGF0ZS5ub3coKSAtICh0aGlzLmxhc3RfcmVxdWVzdF90aW1lIGFzIG51bWJlcikpIDwgdGhpcy5mYWlsX3RpbWVvdXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHVwIGEgcHJveHkuXG4gICAqIEBwYXJhbSB7Kn0gaG9zdG5hbWVcbiAgICogQHBhcmFtIHsqfSBjb25maWdcbiAgICogQHBhcmFtIHsqfSBtYWluY29uZmlnXG4gICAqIEBwYXJhbSB7Kn0gaXNIVFRQU1xuICAgKi9cbiAgcHJpdmF0ZSBfc2V0dXBQcm94eShob3N0bmFtZTogc3RyaW5nLCBjb25maWc6IFVwTGlua0NvbmZMb2NhbCwgbWFpbmNvbmZpZzogQ29uZmlnLCBpc0hUVFBTOiBib29sZWFuKTogdm9pZCB7XG4gICAgbGV0IG5vUHJveHlMaXN0O1xuICAgIGNvbnN0IHByb3h5X2tleTogc3RyaW5nID0gaXNIVFRQUyA/ICdodHRwc19wcm94eScgOiAnaHR0cF9wcm94eSc7XG5cbiAgICAvLyBnZXQgaHR0cF9wcm94eSBhbmQgbm9fcHJveHkgY29uZmlnc1xuICAgIGlmIChwcm94eV9rZXkgaW4gY29uZmlnKSB7XG4gICAgICB0aGlzLnByb3h5ID0gY29uZmlnW3Byb3h5X2tleV07XG4gICAgfSBlbHNlIGlmIChwcm94eV9rZXkgaW4gbWFpbmNvbmZpZykge1xuICAgICAgdGhpcy5wcm94eSA9IG1haW5jb25maWdbcHJveHlfa2V5XTtcbiAgICB9XG4gICAgaWYgKCdub19wcm94eScgaW4gY29uZmlnKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lXG4gICAgICBub1Byb3h5TGlzdCA9IGNvbmZpZy5ub19wcm94eTtcbiAgICB9IGVsc2UgaWYgKCdub19wcm94eScgaW4gbWFpbmNvbmZpZykge1xuICAgICAgbm9Qcm94eUxpc3QgPSBtYWluY29uZmlnLm5vX3Byb3h5O1xuICAgIH1cblxuICAgIC8vIHVzZSB3Z2V0LWxpa2UgYWxnb3JpdGhtIHRvIGRldGVybWluZSBpZiBwcm94eSBzaG91bGRuJ3QgYmUgdXNlZFxuICAgIGlmIChob3N0bmFtZVswXSAhPT0gJy4nKSB7XG4gICAgICBob3N0bmFtZSA9ICcuJyArIGhvc3RuYW1lO1xuICAgIH1cblxuICAgIGlmIChfLmlzU3RyaW5nKG5vUHJveHlMaXN0KSAmJiBub1Byb3h5TGlzdC5sZW5ndGgpIHtcbiAgICAgIC8vICRGbG93Rml4TWVcbiAgICAgIG5vUHJveHlMaXN0ID0gbm9Qcm94eUxpc3Quc3BsaXQoJywnKTtcbiAgICB9XG5cbiAgICBpZiAoXy5pc0FycmF5KG5vUHJveHlMaXN0KSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub1Byb3h5TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9Qcm94eUl0ZW0gPSBub1Byb3h5TGlzdFtpXTtcbiAgICAgICAgaWYgKG5vUHJveHlJdGVtWzBdICE9PSAnLicpIHtcbiAgICAgICAgICBub1Byb3h5SXRlbSA9ICcuJyArIG5vUHJveHlJdGVtO1xuICAgICAgICB9XG4gICAgICAgIGlmIChob3N0bmFtZS5sYXN0SW5kZXhPZihub1Byb3h5SXRlbSkgPT09IGhvc3RuYW1lLmxlbmd0aCAtIG5vUHJveHlJdGVtLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh0aGlzLnByb3h5KSB7XG4gICAgICAgICAgICBkZWJ1Zygnbm90IHVzaW5nIHByb3h5IGZvciAlbywgZXhjbHVkZWQgYnkgJW8gcnVsZScsIHRoaXMudXJsLmhyZWYsIG5vUHJveHlJdGVtKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMucHJveHkgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiBpdCdzIG5vbi1zdHJpbmcgKGkuZS4gXCJmYWxzZVwiKSwgZG9uJ3QgdXNlIGl0XG4gICAgaWYgKF8uaXNTdHJpbmcodGhpcy5wcm94eSkgPT09IGZhbHNlKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBkZWxldGUgdGhpcy5wcm94eTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVidWcoJ3VzaW5nIHByb3h5ICVvIGZvciAlbycsIHRoaXMudXJsLmhyZWYsIHRoaXMucHJveHkpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcm94eVN0b3JhZ2U7XG4iXX0=