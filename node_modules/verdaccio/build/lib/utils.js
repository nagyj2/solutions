"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorCode = void 0;
exports.addGravatarSupport = addGravatarSupport;
exports.addScope = addScope;
exports.buildToken = buildToken;
exports.combineBaseUrl = combineBaseUrl;
exports.convertDistRemoteToLocalTarballUrls = convertDistRemoteToLocalTarballUrls;
exports.convertPayloadToBase64 = convertPayloadToBase64;
exports.deleteProperties = deleteProperties;
exports.encodeScopedUri = encodeScopedUri;
exports.extractTarballFromUrl = extractTarballFromUrl;
exports.fileExists = fileExists;
exports.folderExists = folderExists;
exports.formatAuthor = formatAuthor;
exports.getLatestVersion = getLatestVersion;
exports.getLocalRegistryTarballUri = getLocalRegistryTarballUri;
exports.getPublicUrl = getPublicUrl;
exports.getUserAgent = getUserAgent;
exports.getVersion = getVersion;
exports.getVersionFromTarball = getVersionFromTarball;
exports.getWebProtocol = getWebProtocol;
exports.hasDiffOneKey = hasDiffOneKey;
exports.isHTTPProtocol = isHTTPProtocol;
exports.isHost = isHost;
exports.isObject = isObject;
exports.isObjectOrArray = isObjectOrArray;
exports.isRelatedToDeprecation = isRelatedToDeprecation;
exports.isVersionValid = isVersionValid;
exports.mask = mask;
exports.normalizeDistTags = normalizeDistTags;
exports.pad = pad;
exports.parseAddress = parseAddress;
exports.parseConfigFile = parseConfigFile;
exports.parseInterval = parseInterval;
exports.parseReadme = parseReadme;
exports.semverSort = semverSort;
exports.sortByName = sortByName;
exports.tagVersion = tagVersion;
exports.validateMetadata = validateMetadata;
exports.validateName = validateName;
exports.validatePackage = validatePackage;
exports.validateURL = validateURL;
exports.wrapPrefix = wrapPrefix;

var _fs = _interopRequireDefault(require("fs"));

var _assert = _interopRequireDefault(require("assert"));

var _url = _interopRequireWildcard(require("url"));

var _lodash = _interopRequireDefault(require("lodash"));

var _debug = _interopRequireDefault(require("debug"));

var _semver = _interopRequireDefault(require("semver"));

var _jsYaml = _interopRequireDefault(require("js-yaml"));

var _validator = _interopRequireDefault(require("validator"));

var _memoizee = _interopRequireDefault(require("memoizee"));

var _readme = _interopRequireDefault(require("@verdaccio/readme"));

var _commonsApi = require("@verdaccio/commons-api");

var _user = require("../utils/user");

var _constants = require("./constants");

var _storageUtils = require("./storage-utils");

var _logger = require("./logger");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const debug = (0, _debug.default)('verdaccio'); // eslint-disable-next-line @typescript-eslint/no-unused-vars
// eslint-disable-next-line @typescript-eslint/no-var-requires

require('pkginfo')(module);

const pkgVersion = module.exports.version;
const pkgName = module.exports.name;
const validProtocols = ['https', 'http'];

function getUserAgent(customUserAgent) {
  (0, _assert.default)(_lodash.default.isString(pkgName));
  (0, _assert.default)(_lodash.default.isString(pkgVersion));

  if (customUserAgent === true) {
    return `${pkgName}/${pkgVersion}`;
  } else if (_lodash.default.isString(customUserAgent) && _lodash.default.isEmpty(customUserAgent) === false) {
    return customUserAgent;
  } else if (customUserAgent === false) {
    return '';
  }

  return `${pkgName}/${pkgVersion}`;
}

function convertPayloadToBase64(payload) {
  return Buffer.from(payload, 'base64');
}
/**
 * From normalize-package-data/lib/fixer.js
 * @param {*} name  the package name
 * @return {Boolean} whether is valid or not
 */


function validateName(name) {
  if (_lodash.default.isString(name) === false) {
    return false;
  }

  const normalizedName = name.toLowerCase();
  /**
   * Some context about the first regex
   * - npm used to have a different tarball naming system.
   * eg: http://registry.npmjs.com/thirty-two
   * https://registry.npmjs.org/thirty-two/-/thirty-two@0.0.1.tgz
   * The file name thirty-two@0.0.1.tgz, the version and the pkg name was separated by an at (@)
   * while nowadays the naming system is based in dashes
   * https://registry.npmjs.org/verdaccio/-/verdaccio-1.4.0.tgz
   *
   * more info here: https://github.com/rlidwka/sinopia/issues/75
   */

  return !(!normalizedName.match(/^[-a-zA-Z0-9_.!~*'()@]+$/) || normalizedName.startsWith('.') || // ".bin", etc.
  ['node_modules', '__proto__', 'favicon.ico'].includes(normalizedName));
}
/**
 * Validate a package.
 * @return {Boolean} whether the package is valid or not
 */


function validatePackage(name) {
  const nameList = name.split('/', 2);

  if (nameList.length === 1) {
    // normal package
    return validateName(nameList[0]);
  } // scoped package


  return nameList[0][0] === '@' && validateName(nameList[0].slice(1)) && validateName(nameList[1]);
}
/**
 * Check whether an element is an Object
 * @param {*} obj the element
 * @return {Boolean}
 */


function isObject(obj) {
  return _lodash.default.isObject(obj) && _lodash.default.isNull(obj) === false && _lodash.default.isArray(obj) === false;
}

function isObjectOrArray(obj) {
  return _lodash.default.isObject(obj) && _lodash.default.isNull(obj) === false;
}
/**
 * Validate the package metadata, add additional properties whether are missing within
 * the metadata properties.
 * @param {*} object
 * @param {*} name
 * @return {Object} the object with additional properties as dist-tags ad versions
 */


function validateMetadata(object, name) {
  (0, _assert.default)(isObject(object), 'not a json object');

  _assert.default.strictEqual(object.name, name);

  if (!isObject(object[_constants.DIST_TAGS])) {
    object[_constants.DIST_TAGS] = {};
  }

  if (!isObject(object['versions'])) {
    object['versions'] = {};
  }

  if (!isObject(object['time'])) {
    object['time'] = {};
  }

  return object;
}

function extractTarballFromUrl(url) {
  // @ts-ignore
  return _url.default.parse(url).pathname.replace(/^.*\//, '');
}
/**
 * Iterate a packages's versions and filter each original tarball url.
 * @param {*} pkg
 * @param {*} req
 * @param {*} config
 * @return {String} a filtered package
 */


function convertDistRemoteToLocalTarballUrls(pkg, req, urlPrefix) {
  for (const ver in pkg.versions) {
    if (Object.prototype.hasOwnProperty.call(pkg.versions, ver)) {
      const distName = pkg.versions[ver].dist;

      if (_lodash.default.isNull(distName) === false && _lodash.default.isNull(distName.tarball) === false) {
        distName.tarball = getLocalRegistryTarballUri(distName.tarball, pkg.name, req, urlPrefix);
      }
    }
  }

  return pkg;
}

const memoizedgetPublicUrl = (0, _memoizee.default)(getPublicUrl);
/**
 * Filter a tarball url.
 * @param {*} uri
 * @return {String} a parsed url
 */

function getLocalRegistryTarballUri(uri, pkgName, req, urlPrefix) {
  const currentHost = req.get('host');

  if (!currentHost) {
    return uri;
  }

  const tarballName = extractTarballFromUrl(uri);
  const domainRegistry = memoizedgetPublicUrl(urlPrefix || '', req);
  return `${domainRegistry}${encodeScopedUri(pkgName)}/-/${tarballName}`;
}

function tagVersion(data, version, tag) {
  if (tag && data[_constants.DIST_TAGS][tag] !== version && _semver.default.parse(version, true)) {
    // valid version - store
    data[_constants.DIST_TAGS][tag] = version;
    return true;
  }

  return false;
}
/**
 * Gets version from a package object taking into account semver weirdness.
 * @return {String} return the semantic version of a package
 */


function getVersion(pkg, version) {
  // this condition must allow cast
  if (_lodash.default.isNil(pkg.versions[version]) === false) {
    return pkg.versions[version];
  }

  try {
    version = _semver.default.parse(version, true);

    for (const versionItem in pkg.versions) {
      // $FlowFixMe
      if (version.compare(_semver.default.parse(versionItem, true)) === 0) {
        return pkg.versions[versionItem];
      }
    }
  } catch (err) {
    return undefined;
  }
}
/**
 * Parse an internet address
 * Allow:
 - https:localhost:1234        - protocol + host + port
 - localhost:1234              - host + port
 - 1234                        - port
 - http::1234                  - protocol + port
 - https://localhost:443/      - full url + https
 - http://[::1]:443/           - ipv6
 - unix:/tmp/http.sock         - unix sockets
 - https://unix:/tmp/http.sock - unix sockets (https)
 * @param {*} urlAddress the internet address definition
 * @return {Object|Null} literal object that represent the address parsed
 */


function parseAddress(urlAddress) {
  //
  // TODO: refactor it to something more reasonable?
  //
  //        protocol :  //      (  host  )|(    ipv6     ):  port  /
  let urlPattern = /^((https?):(\/\/)?)?((([^\/:]*)|\[([^\[\]]+)\]):)?(\d+)\/?$/.exec(urlAddress);

  if (urlPattern) {
    return {
      proto: urlPattern[2] || _constants.DEFAULT_PROTOCOL,
      host: urlPattern[6] || urlPattern[7] || _constants.DEFAULT_DOMAIN,
      port: urlPattern[8] || _constants.DEFAULT_PORT
    };
  }

  urlPattern = /^((https?):(\/\/)?)?unix:(.*)$/.exec(urlAddress);

  if (urlPattern) {
    return {
      proto: urlPattern[2] || _constants.DEFAULT_PROTOCOL,
      path: urlPattern[4]
    };
  }

  return null;
}
/**
 * Function filters out bad semver versions and sorts the array.
 * @return {Array} sorted Array
 */


function semverSort(listVersions) {
  return listVersions.filter(function (x) {
    if (!_semver.default.parse(x, true)) {
      _logger.logger.warn({
        ver: x
      }, 'ignoring bad version @{ver}');

      return false;
    }

    return true;
  }) // FIXME: it seems the @types/semver do not handle a legitimate method named 'compareLoose'
  // @ts-ignore
  .sort(_semver.default.compareLoose).map(String);
}
/**
 * Flatten arrays of tags.
 * @param {*} data
 */


function normalizeDistTags(pkg) {
  let sorted;

  if (!pkg[_constants.DIST_TAGS].latest) {
    // overwrite latest with highest known version based on semver sort
    sorted = semverSort(Object.keys(pkg.versions));

    if (sorted && sorted.length) {
      pkg[_constants.DIST_TAGS].latest = sorted.pop();
    }
  }

  for (const tag in pkg[_constants.DIST_TAGS]) {
    if (_lodash.default.isArray(pkg[_constants.DIST_TAGS][tag])) {
      if (pkg[_constants.DIST_TAGS][tag].length) {
        // sort array
        // FIXME: this is clearly wrong, we need to research why this is like this.
        // @ts-ignore
        sorted = semverSort(pkg[_constants.DIST_TAGS][tag]);

        if (sorted.length) {
          // use highest version based on semver sort
          pkg[_constants.DIST_TAGS][tag] = sorted.pop();
        }
      } else {
        delete pkg[_constants.DIST_TAGS][tag];
      }
    } else if (_lodash.default.isString(pkg[_constants.DIST_TAGS][tag])) {
      if (!_semver.default.parse(pkg[_constants.DIST_TAGS][tag], true)) {
        // if the version is invalid, delete the dist-tag entry
        delete pkg[_constants.DIST_TAGS][tag];
      }
    }
  }
}

const parseIntervalTable = {
  '': 1000,
  ms: 1,
  s: 1000,
  m: 60 * 1000,
  h: 60 * 60 * 1000,
  d: 86400000,
  w: 7 * 86400000,
  M: 30 * 86400000,
  y: 365 * 86400000
};
/**
 * Parse an internal string to number
 * @param {*} interval
 * @return {Number}
 */

function parseInterval(interval) {
  if (typeof interval === 'number') {
    return interval * 1000;
  }

  let result = 0;
  let last_suffix = Infinity;
  interval.split(/\s+/).forEach(function (x) {
    if (!x) {
      return;
    }

    const m = x.match(/^((0|[1-9][0-9]*)(\.[0-9]+)?)(ms|s|m|h|d|w|M|y|)$/);

    if (!m || parseIntervalTable[m[4]] >= last_suffix || m[4] === '' && last_suffix !== Infinity) {
      throw Error('invalid interval: ' + interval);
    }

    last_suffix = parseIntervalTable[m[4]];
    result += Number(m[1]) * parseIntervalTable[m[4]];
  });
  return result;
}
/**
 * Detect running protocol (http or https)
 */


function getWebProtocol(headerProtocol, protocol) {
  let returnProtocol;
  const [, defaultProtocol] = validProtocols; // HAProxy variant might return http,http with X-Forwarded-Proto

  if (typeof headerProtocol === 'string' && headerProtocol !== '') {
    debug('header protocol: %o', protocol);
    const commaIndex = headerProtocol.indexOf(',');
    returnProtocol = commaIndex > 0 ? headerProtocol.substr(0, commaIndex) : headerProtocol;
  } else {
    debug('req protocol: %o', headerProtocol);
    returnProtocol = protocol;
  }

  return validProtocols.includes(returnProtocol) ? returnProtocol : defaultProtocol;
}

function getLatestVersion(pkgInfo) {
  return pkgInfo[_constants.DIST_TAGS].latest;
}

const ErrorCode = {
  getConflict: _commonsApi.getConflict,
  getBadData: _commonsApi.getBadData,
  getBadRequest: _commonsApi.getBadRequest,
  getInternalError: _commonsApi.getInternalError,
  getUnauthorized: _commonsApi.getUnauthorized,
  getForbidden: _commonsApi.getForbidden,
  getServiceUnavailable: _commonsApi.getServiceUnavailable,
  getNotFound: _commonsApi.getNotFound,
  getCode: _commonsApi.getCode
};
exports.ErrorCode = ErrorCode;

function parseConfigFile(configPath) {
  try {
    if (/\.ya?ml$/i.test(configPath)) {
      return _jsYaml.default.load(_fs.default.readFileSync(configPath, 'utf-8'));
    }

    debug('yaml parsed');
    return require(configPath);
  } catch (e) {
    debug('yaml parse failed');

    if (e.code !== 'MODULE_NOT_FOUND') {
      e.message = _constants.APP_ERROR.CONFIG_NOT_VALID;
    }

    throw new Error(e);
  }
}
/**
 * Check whether the path already exist.
 * @param {String} path
 * @return {Boolean}
 */


function folderExists(path) {
  try {
    const stat = _fs.default.statSync(path);

    return stat.isDirectory();
  } catch (_) {
    return false;
  }
}
/**
 * Check whether the file already exist.
 * @param {String} path
 * @return {Boolean}
 */


function fileExists(path) {
  try {
    const stat = _fs.default.statSync(path);

    return stat.isFile();
  } catch (_) {
    return false;
  }
}

function sortByName(packages, orderAscending = true) {
  return packages.slice().sort(function (a, b) {
    const comparatorNames = a.name.toLowerCase() < b.name.toLowerCase();
    return orderAscending ? comparatorNames ? -1 : 1 : comparatorNames ? 1 : -1;
  });
}

function addScope(scope, packageName) {
  return `@${scope}/${packageName}`;
}

function deleteProperties(propertiesToDelete, objectItem) {
  _lodash.default.forEach(propertiesToDelete, property => {
    delete objectItem[property];
  });

  return objectItem;
}

function addGravatarSupport(pkgInfo, online = true) {
  const pkgInfoCopy = _objectSpread({}, pkgInfo);

  const author = _lodash.default.get(pkgInfo, 'latest.author', null);

  const contributors = (0, _storageUtils.normalizeContributors)(_lodash.default.get(pkgInfo, 'latest.contributors', []));

  const maintainers = _lodash.default.get(pkgInfo, 'latest.maintainers', []); // for author.


  if (author && _lodash.default.isObject(author)) {
    const {
      email
    } = author;
    pkgInfoCopy.latest.author.avatar = (0, _user.generateGravatarUrl)(email, online);
  }

  if (author && _lodash.default.isString(author)) {
    pkgInfoCopy.latest.author = {
      avatar: _user.GENERIC_AVATAR,
      email: '',
      author
    };
  } // for contributors


  if (_lodash.default.isEmpty(contributors) === false) {
    pkgInfoCopy.latest.contributors = contributors.map(contributor => {
      if (isObject(contributor)) {
        contributor.avatar = (0, _user.generateGravatarUrl)(contributor.email, online);
      } else if (_lodash.default.isString(contributor)) {
        contributor = {
          avatar: _user.GENERIC_AVATAR,
          email: contributor,
          name: contributor
        };
      }

      return contributor;
    });
  } // for maintainers


  if (_lodash.default.isEmpty(maintainers) === false) {
    pkgInfoCopy.latest.maintainers = maintainers.map(maintainer => {
      maintainer.avatar = (0, _user.generateGravatarUrl)(maintainer.email, online);
      return maintainer;
    });
  }

  return pkgInfoCopy;
}
/**
 * parse package readme - markdown/ascii
 * @param {String} packageName name of package
 * @param {String} readme package readme
 * @param {Object} options sanitizyReadme options
 * @return {String} converted html template
 */


function parseReadme(packageName, readme, options = {}) {
  if (_lodash.default.isEmpty(readme) === false) {
    return (0, _readme.default)(readme, options);
  } // logs readme not found error


  _logger.logger.error({
    packageName
  }, '@{packageName}: No readme found');

  return (0, _readme.default)('ERROR: No README data found!');
}

function buildToken(type, token) {
  return `${_lodash.default.capitalize(type)} ${token}`;
}
/**
 * return package version from tarball name
 * @param {String} name
 * @returns {String}
 */


function getVersionFromTarball(name) {
  // FIXME: we know the regex is valid, but we should improve this part as ts suggest
  // @ts-ignore
  return /.+-(\d.+)\.tgz/.test(name) ? name.match(/.+-(\d.+)\.tgz/)[1] : undefined;
}

/**
 * Formats author field for webui.
 * @see https://docs.npmjs.com/files/package.json#author
 * @param {string|object|undefined} author
 */
function formatAuthor(author) {
  let authorDetails = {
    name: _constants.DEFAULT_USER,
    email: '',
    url: ''
  };

  if (_lodash.default.isNil(author)) {
    return authorDetails;
  }

  if (_lodash.default.isString(author)) {
    authorDetails = _objectSpread(_objectSpread({}, authorDetails), {}, {
      name: author
    });
  }

  if (_lodash.default.isObject(author)) {
    authorDetails = _objectSpread(_objectSpread({}, authorDetails), author);
  }

  return authorDetails;
}
/**
 * Check if URI is starting with "http://", "https://" or "//"
 * @param {string} uri
 */


function isHTTPProtocol(uri) {
  return /^(https?:)?\/\//.test(uri);
}
/**
 * Apply whitespaces based on the length
 * @param {*} str the log message
 * @return {String}
 */


function pad(str, max) {
  if (str.length < max) {
    return str + ' '.repeat(max - str.length);
  }

  return str;
}
/**
 * return a masquerade string with its first and last {charNum} and three dots in between.
 * @param {String} str
 * @param {Number} charNum
 * @returns {String}
 */


function mask(str, charNum = 3) {
  return `${str.substr(0, charNum)}...${str.substr(-charNum)}`;
}

function encodeScopedUri(packageName) {
  return packageName.replace(/\//g, '%2f');
}

function hasDiffOneKey(versions) {
  return Object.keys(versions).length !== 1;
}

function isVersionValid(packageMeta, packageVersion) {
  const hasVersion = typeof packageVersion !== 'undefined';

  if (!hasVersion) {
    return false;
  }

  const hasMatchVersion = Object.keys(packageMeta.versions).includes(packageVersion);
  return hasMatchVersion;
}

function isRelatedToDeprecation(pkgInfo) {
  const {
    versions
  } = pkgInfo;

  for (const version in versions) {
    if (Object.prototype.hasOwnProperty.call(versions[version], 'deprecated')) {
      return true;
    }
  }

  return false;
}

function validateURL(publicUrl) {
  try {
    const parsed = new _url.URL(publicUrl);

    if (!validProtocols.includes(parsed.protocol.replace(':', ''))) {
      throw Error('invalid protocol');
    }

    return true;
  } catch (err) {
    // TODO: add error logger here
    return false;
  }
}

function isHost(url = '', options = {}) {
  return _validator.default.isURL(url, _objectSpread({
    require_host: true,
    allow_trailing_dot: false,
    require_valid_protocol: false,
    // @ts-ignore
    require_port: false,
    require_tld: false
  }, options));
}

function getPublicUrl(url_prefix = '', req) {
  if (validateURL(process.env.VERDACCIO_PUBLIC_URL)) {
    const envURL = new _url.URL(wrapPrefix(url_prefix), process.env.VERDACCIO_PUBLIC_URL).href;
    debug('public url by env %o', envURL);
    return envURL;
  } else if (req.get('host')) {
    var _process$env$VERDACCI;

    const host = req.get('host');

    if (!isHost(host)) {
      throw new Error('invalid host');
    }

    const protoHeader = (_process$env$VERDACCI = process.env.VERDACCIO_FORWARDED_PROTO) !== null && _process$env$VERDACCI !== void 0 ? _process$env$VERDACCI : _constants.HEADERS.FORWARDED_PROTO;
    const protocol = getWebProtocol(req.get(protoHeader.toLowerCase()), req.protocol);
    const combinedUrl = combineBaseUrl(protocol, host, url_prefix);
    debug('public url by request %o', combinedUrl);
    return combinedUrl;
  } else {
    return '/';
  }
}
/**
 * Create base url for registry.
 * @return {String} base registry url
 */


function combineBaseUrl(protocol, host, prefix = '') {
  debug('combined protocol %o', protocol);
  debug('combined host %o', host);
  const newPrefix = wrapPrefix(prefix);
  debug('combined prefix %o', newPrefix);
  const groupedURI = new _url.URL(wrapPrefix(prefix), `${protocol}://${host}`);
  const result = groupedURI.href;
  debug('combined url %o', result);
  return result;
}

function wrapPrefix(prefix) {
  if (prefix === '' || typeof prefix === 'undefined' || prefix === null) {
    return '';
  } else if (!prefix.startsWith('/') && prefix.endsWith('/')) {
    return `/${prefix}`;
  } else if (!prefix.startsWith('/') && !prefix.endsWith('/')) {
    return `/${prefix}/`;
  } else if (prefix.startsWith('/') && !prefix.endsWith('/')) {
    return `${prefix}/`;
  } else {
    return prefix;
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvdXRpbHMudHMiXSwibmFtZXMiOlsiZGVidWciLCJyZXF1aXJlIiwibW9kdWxlIiwicGtnVmVyc2lvbiIsImV4cG9ydHMiLCJ2ZXJzaW9uIiwicGtnTmFtZSIsIm5hbWUiLCJ2YWxpZFByb3RvY29scyIsImdldFVzZXJBZ2VudCIsImN1c3RvbVVzZXJBZ2VudCIsIl8iLCJpc1N0cmluZyIsImlzRW1wdHkiLCJjb252ZXJ0UGF5bG9hZFRvQmFzZTY0IiwicGF5bG9hZCIsIkJ1ZmZlciIsImZyb20iLCJ2YWxpZGF0ZU5hbWUiLCJub3JtYWxpemVkTmFtZSIsInRvTG93ZXJDYXNlIiwibWF0Y2giLCJzdGFydHNXaXRoIiwiaW5jbHVkZXMiLCJ2YWxpZGF0ZVBhY2thZ2UiLCJuYW1lTGlzdCIsInNwbGl0IiwibGVuZ3RoIiwic2xpY2UiLCJpc09iamVjdCIsIm9iaiIsImlzTnVsbCIsImlzQXJyYXkiLCJpc09iamVjdE9yQXJyYXkiLCJ2YWxpZGF0ZU1ldGFkYXRhIiwib2JqZWN0IiwiYXNzZXJ0Iiwic3RyaWN0RXF1YWwiLCJESVNUX1RBR1MiLCJleHRyYWN0VGFyYmFsbEZyb21VcmwiLCJ1cmwiLCJEZWZhdWx0VVJMIiwicGFyc2UiLCJwYXRobmFtZSIsInJlcGxhY2UiLCJjb252ZXJ0RGlzdFJlbW90ZVRvTG9jYWxUYXJiYWxsVXJscyIsInBrZyIsInJlcSIsInVybFByZWZpeCIsInZlciIsInZlcnNpb25zIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiZGlzdE5hbWUiLCJkaXN0IiwidGFyYmFsbCIsImdldExvY2FsUmVnaXN0cnlUYXJiYWxsVXJpIiwibWVtb2l6ZWRnZXRQdWJsaWNVcmwiLCJnZXRQdWJsaWNVcmwiLCJ1cmkiLCJjdXJyZW50SG9zdCIsImdldCIsInRhcmJhbGxOYW1lIiwiZG9tYWluUmVnaXN0cnkiLCJlbmNvZGVTY29wZWRVcmkiLCJ0YWdWZXJzaW9uIiwiZGF0YSIsInRhZyIsInNlbXZlciIsImdldFZlcnNpb24iLCJpc05pbCIsInZlcnNpb25JdGVtIiwiY29tcGFyZSIsImVyciIsInVuZGVmaW5lZCIsInBhcnNlQWRkcmVzcyIsInVybEFkZHJlc3MiLCJ1cmxQYXR0ZXJuIiwiZXhlYyIsInByb3RvIiwiREVGQVVMVF9QUk9UT0NPTCIsImhvc3QiLCJERUZBVUxUX0RPTUFJTiIsInBvcnQiLCJERUZBVUxUX1BPUlQiLCJwYXRoIiwic2VtdmVyU29ydCIsImxpc3RWZXJzaW9ucyIsImZpbHRlciIsIngiLCJsb2dnZXIiLCJ3YXJuIiwic29ydCIsImNvbXBhcmVMb29zZSIsIm1hcCIsIlN0cmluZyIsIm5vcm1hbGl6ZURpc3RUYWdzIiwic29ydGVkIiwibGF0ZXN0Iiwia2V5cyIsInBvcCIsInBhcnNlSW50ZXJ2YWxUYWJsZSIsIm1zIiwicyIsIm0iLCJoIiwiZCIsInciLCJNIiwieSIsInBhcnNlSW50ZXJ2YWwiLCJpbnRlcnZhbCIsInJlc3VsdCIsImxhc3Rfc3VmZml4IiwiSW5maW5pdHkiLCJmb3JFYWNoIiwiRXJyb3IiLCJOdW1iZXIiLCJnZXRXZWJQcm90b2NvbCIsImhlYWRlclByb3RvY29sIiwicHJvdG9jb2wiLCJyZXR1cm5Qcm90b2NvbCIsImRlZmF1bHRQcm90b2NvbCIsImNvbW1hSW5kZXgiLCJpbmRleE9mIiwic3Vic3RyIiwiZ2V0TGF0ZXN0VmVyc2lvbiIsInBrZ0luZm8iLCJFcnJvckNvZGUiLCJnZXRDb25mbGljdCIsImdldEJhZERhdGEiLCJnZXRCYWRSZXF1ZXN0IiwiZ2V0SW50ZXJuYWxFcnJvciIsImdldFVuYXV0aG9yaXplZCIsImdldEZvcmJpZGRlbiIsImdldFNlcnZpY2VVbmF2YWlsYWJsZSIsImdldE5vdEZvdW5kIiwiZ2V0Q29kZSIsInBhcnNlQ29uZmlnRmlsZSIsImNvbmZpZ1BhdGgiLCJ0ZXN0IiwiWUFNTCIsImxvYWQiLCJmcyIsInJlYWRGaWxlU3luYyIsImUiLCJjb2RlIiwibWVzc2FnZSIsIkFQUF9FUlJPUiIsIkNPTkZJR19OT1RfVkFMSUQiLCJmb2xkZXJFeGlzdHMiLCJzdGF0Iiwic3RhdFN5bmMiLCJpc0RpcmVjdG9yeSIsImZpbGVFeGlzdHMiLCJpc0ZpbGUiLCJzb3J0QnlOYW1lIiwicGFja2FnZXMiLCJvcmRlckFzY2VuZGluZyIsImEiLCJiIiwiY29tcGFyYXRvck5hbWVzIiwiYWRkU2NvcGUiLCJzY29wZSIsInBhY2thZ2VOYW1lIiwiZGVsZXRlUHJvcGVydGllcyIsInByb3BlcnRpZXNUb0RlbGV0ZSIsIm9iamVjdEl0ZW0iLCJwcm9wZXJ0eSIsImFkZEdyYXZhdGFyU3VwcG9ydCIsIm9ubGluZSIsInBrZ0luZm9Db3B5IiwiYXV0aG9yIiwiY29udHJpYnV0b3JzIiwibWFpbnRhaW5lcnMiLCJlbWFpbCIsImF2YXRhciIsIkdFTkVSSUNfQVZBVEFSIiwiY29udHJpYnV0b3IiLCJtYWludGFpbmVyIiwicGFyc2VSZWFkbWUiLCJyZWFkbWUiLCJvcHRpb25zIiwiZXJyb3IiLCJidWlsZFRva2VuIiwidHlwZSIsInRva2VuIiwiY2FwaXRhbGl6ZSIsImdldFZlcnNpb25Gcm9tVGFyYmFsbCIsImZvcm1hdEF1dGhvciIsImF1dGhvckRldGFpbHMiLCJERUZBVUxUX1VTRVIiLCJpc0hUVFBQcm90b2NvbCIsInBhZCIsInN0ciIsIm1heCIsInJlcGVhdCIsIm1hc2siLCJjaGFyTnVtIiwiaGFzRGlmZk9uZUtleSIsImlzVmVyc2lvblZhbGlkIiwicGFja2FnZU1ldGEiLCJwYWNrYWdlVmVyc2lvbiIsImhhc1ZlcnNpb24iLCJoYXNNYXRjaFZlcnNpb24iLCJpc1JlbGF0ZWRUb0RlcHJlY2F0aW9uIiwidmFsaWRhdGVVUkwiLCJwdWJsaWNVcmwiLCJwYXJzZWQiLCJVUkwiLCJpc0hvc3QiLCJ2YWxpZGF0b3IiLCJpc1VSTCIsInJlcXVpcmVfaG9zdCIsImFsbG93X3RyYWlsaW5nX2RvdCIsInJlcXVpcmVfdmFsaWRfcHJvdG9jb2wiLCJyZXF1aXJlX3BvcnQiLCJyZXF1aXJlX3RsZCIsInVybF9wcmVmaXgiLCJwcm9jZXNzIiwiZW52IiwiVkVSREFDQ0lPX1BVQkxJQ19VUkwiLCJlbnZVUkwiLCJ3cmFwUHJlZml4IiwiaHJlZiIsInByb3RvSGVhZGVyIiwiVkVSREFDQ0lPX0ZPUldBUkRFRF9QUk9UTyIsIkhFQURFUlMiLCJGT1JXQVJERURfUFJPVE8iLCJjb21iaW5lZFVybCIsImNvbWJpbmVCYXNlVXJsIiwicHJlZml4IiwibmV3UHJlZml4IiwiZ3JvdXBlZFVSSSIsImVuZHNXaXRoIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFLQTs7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7QUFFQSxNQUFNQSxLQUFLLEdBQUcsb0JBQVcsV0FBWCxDQUFkLEMsQ0FFQTtBQUNBOztBQUNBQyxPQUFPLENBQUMsU0FBRCxDQUFQLENBQW1CQyxNQUFuQjs7QUFDQSxNQUFNQyxVQUFVLEdBQUdELE1BQU0sQ0FBQ0UsT0FBUCxDQUFlQyxPQUFsQztBQUNBLE1BQU1DLE9BQU8sR0FBR0osTUFBTSxDQUFDRSxPQUFQLENBQWVHLElBQS9CO0FBQ0EsTUFBTUMsY0FBYyxHQUFHLENBQUMsT0FBRCxFQUFVLE1BQVYsQ0FBdkI7O0FBRU8sU0FBU0MsWUFBVCxDQUFzQkMsZUFBdEIsRUFBa0U7QUFDdkUsdUJBQU9DLGdCQUFFQyxRQUFGLENBQVdOLE9BQVgsQ0FBUDtBQUNBLHVCQUFPSyxnQkFBRUMsUUFBRixDQUFXVCxVQUFYLENBQVA7O0FBQ0EsTUFBSU8sZUFBZSxLQUFLLElBQXhCLEVBQThCO0FBQzVCLFdBQVEsR0FBRUosT0FBUSxJQUFHSCxVQUFXLEVBQWhDO0FBQ0QsR0FGRCxNQUVPLElBQUlRLGdCQUFFQyxRQUFGLENBQVdGLGVBQVgsS0FBK0JDLGdCQUFFRSxPQUFGLENBQVVILGVBQVYsTUFBK0IsS0FBbEUsRUFBeUU7QUFDOUUsV0FBT0Es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XG5pbXBvcnQgYXNzZXJ0IGZyb20gJ2Fzc2VydCc7XG5pbXBvcnQgRGVmYXVsdFVSTCwgeyBVUkwgfSBmcm9tICd1cmwnO1xuaW1wb3J0IF8gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBidWlsZERlYnVnIGZyb20gJ2RlYnVnJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbmltcG9ydCBZQU1MIGZyb20gJ2pzLXlhbWwnO1xuaW1wb3J0IHZhbGlkYXRvciBmcm9tICd2YWxpZGF0b3InO1xuaW1wb3J0IG1lbW9pemVlIGZyb20gJ21lbW9pemVlJztcbmltcG9ydCBzYW5pdGl6eVJlYWRtZSBmcm9tICdAdmVyZGFjY2lvL3JlYWRtZSc7XG5cbmltcG9ydCB7IFBhY2thZ2UsIFZlcnNpb24sIEF1dGhvciB9IGZyb20gJ0B2ZXJkYWNjaW8vdHlwZXMnO1xuaW1wb3J0IHsgUmVxdWVzdCB9IGZyb20gJ2V4cHJlc3MnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbmltcG9ydCB7IGdldENvbmZsaWN0LCBnZXRCYWREYXRhLCBnZXRCYWRSZXF1ZXN0LCBnZXRJbnRlcm5hbEVycm9yLCBnZXRVbmF1dGhvcml6ZWQsIGdldEZvcmJpZGRlbiwgZ2V0U2VydmljZVVuYXZhaWxhYmxlLCBnZXROb3RGb3VuZCwgZ2V0Q29kZSB9IGZyb20gJ0B2ZXJkYWNjaW8vY29tbW9ucy1hcGknO1xuaW1wb3J0IHsgZ2VuZXJhdGVHcmF2YXRhclVybCwgR0VORVJJQ19BVkFUQVIgfSBmcm9tICcuLi91dGlscy91c2VyJztcbmltcG9ydCB7IFN0cmluZ1ZhbHVlLCBBdXRob3JBdmF0YXIgfSBmcm9tICcuLi8uLi90eXBlcyc7XG5pbXBvcnQgeyBBUFBfRVJST1IsIERFRkFVTFRfUE9SVCwgREVGQVVMVF9ET01BSU4sIERFRkFVTFRfUFJPVE9DT0wsIEhFQURFUlMsIERJU1RfVEFHUywgREVGQVVMVF9VU0VSIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5pbXBvcnQgeyBub3JtYWxpemVDb250cmlidXRvcnMgfSBmcm9tICcuL3N0b3JhZ2UtdXRpbHMnO1xuXG5pbXBvcnQgeyBsb2dnZXIgfSBmcm9tICcuL2xvZ2dlcic7XG5cbmNvbnN0IGRlYnVnID0gYnVpbGREZWJ1ZygndmVyZGFjY2lvJyk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdmFyLXJlcXVpcmVzXG5yZXF1aXJlKCdwa2dpbmZvJykobW9kdWxlKTtcbmNvbnN0IHBrZ1ZlcnNpb24gPSBtb2R1bGUuZXhwb3J0cy52ZXJzaW9uO1xuY29uc3QgcGtnTmFtZSA9IG1vZHVsZS5leHBvcnRzLm5hbWU7XG5jb25zdCB2YWxpZFByb3RvY29scyA9IFsnaHR0cHMnLCAnaHR0cCddO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VXNlckFnZW50KGN1c3RvbVVzZXJBZ2VudD86IGJvb2xlYW4gfCBzdHJpbmcpOiBzdHJpbmcge1xuICBhc3NlcnQoXy5pc1N0cmluZyhwa2dOYW1lKSk7XG4gIGFzc2VydChfLmlzU3RyaW5nKHBrZ1ZlcnNpb24pKTtcbiAgaWYgKGN1c3RvbVVzZXJBZ2VudCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBgJHtwa2dOYW1lfS8ke3BrZ1ZlcnNpb259YDtcbiAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGN1c3RvbVVzZXJBZ2VudCkgJiYgXy5pc0VtcHR5KGN1c3RvbVVzZXJBZ2VudCkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGN1c3RvbVVzZXJBZ2VudDtcbiAgfSBlbHNlIGlmIChjdXN0b21Vc2VyQWdlbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgcmV0dXJuIGAke3BrZ05hbWV9LyR7cGtnVmVyc2lvbn1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFBheWxvYWRUb0Jhc2U2NChwYXlsb2FkOiBzdHJpbmcpOiBCdWZmZXIge1xuICByZXR1cm4gQnVmZmVyLmZyb20ocGF5bG9hZCwgJ2Jhc2U2NCcpO1xufVxuXG4vKipcbiAqIEZyb20gbm9ybWFsaXplLXBhY2thZ2UtZGF0YS9saWIvZml4ZXIuanNcbiAqIEBwYXJhbSB7Kn0gbmFtZSAgdGhlIHBhY2thZ2UgbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBpcyB2YWxpZCBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTmFtZShuYW1lOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKF8uaXNTdHJpbmcobmFtZSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3Qgbm9ybWFsaXplZE5hbWU6IHN0cmluZyA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAvKipcbiAgICogU29tZSBjb250ZXh0IGFib3V0IHRoZSBmaXJzdCByZWdleFxuICAgKiAtIG5wbSB1c2VkIHRvIGhhdmUgYSBkaWZmZXJlbnQgdGFyYmFsbCBuYW1pbmcgc3lzdGVtLlxuICAgKiBlZzogaHR0cDovL3JlZ2lzdHJ5Lm5wbWpzLmNvbS90aGlydHktdHdvXG4gICAqIGh0dHBzOi8vcmVnaXN0cnkubnBtanMub3JnL3RoaXJ0eS10d28vLS90aGlydHktdHdvQDAuMC4xLnRnelxuICAgKiBUaGUgZmlsZSBuYW1lIHRoaXJ0eS10d29AMC4wLjEudGd6LCB0aGUgdmVyc2lvbiBhbmQgdGhlIHBrZyBuYW1lIHdhcyBzZXBhcmF0ZWQgYnkgYW4gYXQgKEApXG4gICAqIHdoaWxlIG5vd2FkYXlzIHRoZSBuYW1pbmcgc3lzdGVtIGlzIGJhc2VkIGluIGRhc2hlc1xuICAgKiBodHRwczovL3JlZ2lzdHJ5Lm5wbWpzLm9yZy92ZXJkYWNjaW8vLS92ZXJkYWNjaW8tMS40LjAudGd6XG4gICAqXG4gICAqIG1vcmUgaW5mbyBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vcmxpZHdrYS9zaW5vcGlhL2lzc3Vlcy83NVxuICAgKi9cbiAgcmV0dXJuICEoXG4gICAgIW5vcm1hbGl6ZWROYW1lLm1hdGNoKC9eWy1hLXpBLVowLTlfLiF+KicoKUBdKyQvKSB8fFxuICAgIG5vcm1hbGl6ZWROYW1lLnN0YXJ0c1dpdGgoJy4nKSB8fCAvLyBcIi5iaW5cIiwgZXRjLlxuICAgIFsnbm9kZV9tb2R1bGVzJywgJ19fcHJvdG9fXycsICdmYXZpY29uLmljbyddLmluY2x1ZGVzKG5vcm1hbGl6ZWROYW1lKVxuICApO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIGEgcGFja2FnZS5cbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhlIHBhY2thZ2UgaXMgdmFsaWQgb3Igbm90XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBhY2thZ2UobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IG5hbWVMaXN0ID0gbmFtZS5zcGxpdCgnLycsIDIpO1xuICBpZiAobmFtZUxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gbm9ybWFsIHBhY2thZ2VcbiAgICByZXR1cm4gdmFsaWRhdGVOYW1lKG5hbWVMaXN0WzBdKTtcbiAgfVxuICAvLyBzY29wZWQgcGFja2FnZVxuICByZXR1cm4gbmFtZUxpc3RbMF1bMF0gPT09ICdAJyAmJiB2YWxpZGF0ZU5hbWUobmFtZUxpc3RbMF0uc2xpY2UoMSkpICYmIHZhbGlkYXRlTmFtZShuYW1lTGlzdFsxXSk7XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciBhbiBlbGVtZW50IGlzIGFuIE9iamVjdFxuICogQHBhcmFtIHsqfSBvYmogdGhlIGVsZW1lbnRcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChvYmo6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gXy5pc09iamVjdChvYmopICYmIF8uaXNOdWxsKG9iaikgPT09IGZhbHNlICYmIF8uaXNBcnJheShvYmopID09PSBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0T3JBcnJheShvYmo6IGFueSk6IGJvb2xlYW4ge1xuICByZXR1cm4gXy5pc09iamVjdChvYmopICYmIF8uaXNOdWxsKG9iaikgPT09IGZhbHNlO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlIHRoZSBwYWNrYWdlIG1ldGFkYXRhLCBhZGQgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHdoZXRoZXIgYXJlIG1pc3Npbmcgd2l0aGluXG4gKiB0aGUgbWV0YWRhdGEgcHJvcGVydGllcy5cbiAqIEBwYXJhbSB7Kn0gb2JqZWN0XG4gKiBAcGFyYW0geyp9IG5hbWVcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIG9iamVjdCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyBhcyBkaXN0LXRhZ3MgYWQgdmVyc2lvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlTWV0YWRhdGEob2JqZWN0OiBQYWNrYWdlLCBuYW1lOiBzdHJpbmcpOiBQYWNrYWdlIHtcbiAgYXNzZXJ0KGlzT2JqZWN0KG9iamVjdCksICdub3QgYSBqc29uIG9iamVjdCcpO1xuICBhc3NlcnQuc3RyaWN0RXF1YWwob2JqZWN0Lm5hbWUsIG5hbWUpO1xuXG4gIGlmICghaXNPYmplY3Qob2JqZWN0W0RJU1RfVEFHU10pKSB7XG4gICAgb2JqZWN0W0RJU1RfVEFHU10gPSB7fTtcbiAgfVxuXG4gIGlmICghaXNPYmplY3Qob2JqZWN0Wyd2ZXJzaW9ucyddKSkge1xuICAgIG9iamVjdFsndmVyc2lvbnMnXSA9IHt9O1xuICB9XG5cbiAgaWYgKCFpc09iamVjdChvYmplY3RbJ3RpbWUnXSkpIHtcbiAgICBvYmplY3RbJ3RpbWUnXSA9IHt9O1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3RUYXJiYWxsRnJvbVVybCh1cmw6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIERlZmF1bHRVUkwucGFyc2UodXJsKS5wYXRobmFtZS5yZXBsYWNlKC9eLipcXC8vLCAnJyk7XG59XG5cbi8qKlxuICogSXRlcmF0ZSBhIHBhY2thZ2VzJ3MgdmVyc2lvbnMgYW5kIGZpbHRlciBlYWNoIG9yaWdpbmFsIHRhcmJhbGwgdXJsLlxuICogQHBhcmFtIHsqfSBwa2dcbiAqIEBwYXJhbSB7Kn0gcmVxXG4gKiBAcGFyYW0geyp9IGNvbmZpZ1xuICogQHJldHVybiB7U3RyaW5nfSBhIGZpbHRlcmVkIHBhY2thZ2VcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnREaXN0UmVtb3RlVG9Mb2NhbFRhcmJhbGxVcmxzKHBrZzogUGFja2FnZSwgcmVxOiBSZXF1ZXN0LCB1cmxQcmVmaXg6IHN0cmluZyB8IHZvaWQpOiBQYWNrYWdlIHtcbiAgZm9yIChjb25zdCB2ZXIgaW4gcGtnLnZlcnNpb25zKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwa2cudmVyc2lvbnMsIHZlcikpIHtcbiAgICAgIGNvbnN0IGRpc3ROYW1lID0gcGtnLnZlcnNpb25zW3Zlcl0uZGlzdDtcblxuICAgICAgaWYgKF8uaXNOdWxsKGRpc3ROYW1lKSA9PT0gZmFsc2UgJiYgXy5pc051bGwoZGlzdE5hbWUudGFyYmFsbCkgPT09IGZhbHNlKSB7XG4gICAgICAgIGRpc3ROYW1lLnRhcmJhbGwgPSBnZXRMb2NhbFJlZ2lzdHJ5VGFyYmFsbFVyaShkaXN0TmFtZS50YXJiYWxsLCBwa2cubmFtZSwgcmVxLCB1cmxQcmVmaXgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGtnO1xufVxuXG5jb25zdCBtZW1vaXplZGdldFB1YmxpY1VybCA9IG1lbW9pemVlKGdldFB1YmxpY1VybCk7XG5cbi8qKlxuICogRmlsdGVyIGEgdGFyYmFsbCB1cmwuXG4gKiBAcGFyYW0geyp9IHVyaVxuICogQHJldHVybiB7U3RyaW5nfSBhIHBhcnNlZCB1cmxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldExvY2FsUmVnaXN0cnlUYXJiYWxsVXJpKHVyaTogc3RyaW5nLCBwa2dOYW1lOiBzdHJpbmcsIHJlcTogUmVxdWVzdCwgdXJsUHJlZml4OiBzdHJpbmcgfCB2b2lkKTogc3RyaW5nIHtcbiAgY29uc3QgY3VycmVudEhvc3QgPSByZXEuZ2V0KCdob3N0Jyk7XG5cbiAgaWYgKCFjdXJyZW50SG9zdCkge1xuICAgIHJldHVybiB1cmk7XG4gIH1cbiAgY29uc3QgdGFyYmFsbE5hbWUgPSBleHRyYWN0VGFyYmFsbEZyb21VcmwodXJpKTtcbiAgY29uc3QgZG9tYWluUmVnaXN0cnkgPSBtZW1vaXplZGdldFB1YmxpY1VybCh1cmxQcmVmaXggfHwgJycsIHJlcSk7XG5cbiAgcmV0dXJuIGAke2RvbWFpblJlZ2lzdHJ5fSR7ZW5jb2RlU2NvcGVkVXJpKHBrZ05hbWUpfS8tLyR7dGFyYmFsbE5hbWV9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhZ1ZlcnNpb24oZGF0YTogUGFja2FnZSwgdmVyc2lvbjogc3RyaW5nLCB0YWc6IFN0cmluZ1ZhbHVlKTogYm9vbGVhbiB7XG4gIGlmICh0YWcgJiYgZGF0YVtESVNUX1RBR1NdW3RhZ10gIT09IHZlcnNpb24gJiYgc2VtdmVyLnBhcnNlKHZlcnNpb24sIHRydWUpKSB7XG4gICAgLy8gdmFsaWQgdmVyc2lvbiAtIHN0b3JlXG4gICAgZGF0YVtESVNUX1RBR1NdW3RhZ10gPSB2ZXJzaW9uO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXRzIHZlcnNpb24gZnJvbSBhIHBhY2thZ2Ugb2JqZWN0IHRha2luZyBpbnRvIGFjY291bnQgc2VtdmVyIHdlaXJkbmVzcy5cbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJuIHRoZSBzZW1hbnRpYyB2ZXJzaW9uIG9mIGEgcGFja2FnZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVyc2lvbihwa2c6IFBhY2thZ2UsIHZlcnNpb246IGFueSk6IFZlcnNpb24gfCB2b2lkIHtcbiAgLy8gdGhpcyBjb25kaXRpb24gbXVzdCBhbGxvdyBjYXN0XG4gIGlmIChfLmlzTmlsKHBrZy52ZXJzaW9uc1t2ZXJzaW9uXSkgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIHBrZy52ZXJzaW9uc1t2ZXJzaW9uXTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgdmVyc2lvbiA9IHNlbXZlci5wYXJzZSh2ZXJzaW9uLCB0cnVlKTtcbiAgICBmb3IgKGNvbnN0IHZlcnNpb25JdGVtIGluIHBrZy52ZXJzaW9ucykge1xuICAgICAgLy8gJEZsb3dGaXhNZVxuICAgICAgaWYgKHZlcnNpb24uY29tcGFyZShzZW12ZXIucGFyc2UodmVyc2lvbkl0ZW0sIHRydWUpKSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gcGtnLnZlcnNpb25zW3ZlcnNpb25JdGVtXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBpbnRlcm5ldCBhZGRyZXNzXG4gKiBBbGxvdzpcbiAtIGh0dHBzOmxvY2FsaG9zdDoxMjM0ICAgICAgICAtIHByb3RvY29sICsgaG9zdCArIHBvcnRcbiAtIGxvY2FsaG9zdDoxMjM0ICAgICAgICAgICAgICAtIGhvc3QgKyBwb3J0XG4gLSAxMjM0ICAgICAgICAgICAgICAgICAgICAgICAgLSBwb3J0XG4gLSBodHRwOjoxMjM0ICAgICAgICAgICAgICAgICAgLSBwcm90b2NvbCArIHBvcnRcbiAtIGh0dHBzOi8vbG9jYWxob3N0OjQ0My8gICAgICAtIGZ1bGwgdXJsICsgaHR0cHNcbiAtIGh0dHA6Ly9bOjoxXTo0NDMvICAgICAgICAgICAtIGlwdjZcbiAtIHVuaXg6L3RtcC9odHRwLnNvY2sgICAgICAgICAtIHVuaXggc29ja2V0c1xuIC0gaHR0cHM6Ly91bml4Oi90bXAvaHR0cC5zb2NrIC0gdW5peCBzb2NrZXRzIChodHRwcylcbiAqIEBwYXJhbSB7Kn0gdXJsQWRkcmVzcyB0aGUgaW50ZXJuZXQgYWRkcmVzcyBkZWZpbml0aW9uXG4gKiBAcmV0dXJuIHtPYmplY3R8TnVsbH0gbGl0ZXJhbCBvYmplY3QgdGhhdCByZXByZXNlbnQgdGhlIGFkZHJlc3MgcGFyc2VkXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUFkZHJlc3ModXJsQWRkcmVzczogYW55KTogYW55IHtcbiAgLy9cbiAgLy8gVE9ETzogcmVmYWN0b3IgaXQgdG8gc29tZXRoaW5nIG1vcmUgcmVhc29uYWJsZT9cbiAgLy9cbiAgLy8gICAgICAgIHByb3RvY29sIDogIC8vICAgICAgKCAgaG9zdCAgKXwoICAgIGlwdjYgICAgICk6ICBwb3J0ICAvXG4gIGxldCB1cmxQYXR0ZXJuID0gL14oKGh0dHBzPyk6KFxcL1xcLyk/KT8oKChbXlxcLzpdKil8XFxbKFteXFxbXFxdXSspXFxdKTopPyhcXGQrKVxcLz8kLy5leGVjKHVybEFkZHJlc3MpO1xuXG4gIGlmICh1cmxQYXR0ZXJuKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RvOiB1cmxQYXR0ZXJuWzJdIHx8IERFRkFVTFRfUFJPVE9DT0wsXG4gICAgICBob3N0OiB1cmxQYXR0ZXJuWzZdIHx8IHVybFBhdHRlcm5bN10gfHwgREVGQVVMVF9ET01BSU4sXG4gICAgICBwb3J0OiB1cmxQYXR0ZXJuWzhdIHx8IERFRkFVTFRfUE9SVCxcbiAgICB9O1xuICB9XG5cbiAgdXJsUGF0dGVybiA9IC9eKChodHRwcz8pOihcXC9cXC8pPyk/dW5peDooLiopJC8uZXhlYyh1cmxBZGRyZXNzKTtcblxuICBpZiAodXJsUGF0dGVybikge1xuICAgIHJldHVybiB7XG4gICAgICBwcm90bzogdXJsUGF0dGVyblsyXSB8fCBERUZBVUxUX1BST1RPQ09MLFxuICAgICAgcGF0aDogdXJsUGF0dGVybls0XSxcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gZmlsdGVycyBvdXQgYmFkIHNlbXZlciB2ZXJzaW9ucyBhbmQgc29ydHMgdGhlIGFycmF5LlxuICogQHJldHVybiB7QXJyYXl9IHNvcnRlZCBBcnJheVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2VtdmVyU29ydChsaXN0VmVyc2lvbnM6IHN0cmluZ1tdKTogc3RyaW5nW10ge1xuICByZXR1cm4gKFxuICAgIGxpc3RWZXJzaW9uc1xuICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCk6IGJvb2xlYW4ge1xuICAgICAgICBpZiAoIXNlbXZlci5wYXJzZSh4LCB0cnVlKSkge1xuICAgICAgICAgIGxvZ2dlci53YXJuKHsgdmVyOiB4IH0sICdpZ25vcmluZyBiYWQgdmVyc2lvbiBAe3Zlcn0nKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KVxuICAgICAgLy8gRklYTUU6IGl0IHNlZW1zIHRoZSBAdHlwZXMvc2VtdmVyIGRvIG5vdCBoYW5kbGUgYSBsZWdpdGltYXRlIG1ldGhvZCBuYW1lZCAnY29tcGFyZUxvb3NlJ1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgLnNvcnQoc2VtdmVyLmNvbXBhcmVMb29zZSlcbiAgICAgIC5tYXAoU3RyaW5nKVxuICApO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYXJyYXlzIG9mIHRhZ3MuXG4gKiBAcGFyYW0geyp9IGRhdGFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZURpc3RUYWdzKHBrZzogUGFja2FnZSk6IHZvaWQge1xuICBsZXQgc29ydGVkO1xuICBpZiAoIXBrZ1tESVNUX1RBR1NdLmxhdGVzdCkge1xuICAgIC8vIG92ZXJ3cml0ZSBsYXRlc3Qgd2l0aCBoaWdoZXN0IGtub3duIHZlcnNpb24gYmFzZWQgb24gc2VtdmVyIHNvcnRcbiAgICBzb3J0ZWQgPSBzZW12ZXJTb3J0KE9iamVjdC5rZXlzKHBrZy52ZXJzaW9ucykpO1xuICAgIGlmIChzb3J0ZWQgJiYgc29ydGVkLmxlbmd0aCkge1xuICAgICAgcGtnW0RJU1RfVEFHU10ubGF0ZXN0ID0gc29ydGVkLnBvcCgpO1xuICAgIH1cbiAgfVxuXG4gIGZvciAoY29uc3QgdGFnIGluIHBrZ1tESVNUX1RBR1NdKSB7XG4gICAgaWYgKF8uaXNBcnJheShwa2dbRElTVF9UQUdTXVt0YWddKSkge1xuICAgICAgaWYgKHBrZ1tESVNUX1RBR1NdW3RhZ10ubGVuZ3RoKSB7XG4gICAgICAgIC8vIHNvcnQgYXJyYXlcbiAgICAgICAgLy8gRklYTUU6IHRoaXMgaXMgY2xlYXJseSB3cm9uZywgd2UgbmVlZCB0byByZXNlYXJjaCB3aHkgdGhpcyBpcyBsaWtlIHRoaXMuXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgc29ydGVkID0gc2VtdmVyU29ydChwa2dbRElTVF9UQUdTXVt0YWddKTtcbiAgICAgICAgaWYgKHNvcnRlZC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyB1c2UgaGlnaGVzdCB2ZXJzaW9uIGJhc2VkIG9uIHNlbXZlciBzb3J0XG4gICAgICAgICAgcGtnW0RJU1RfVEFHU11bdGFnXSA9IHNvcnRlZC5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHBrZ1tESVNUX1RBR1NdW3RhZ107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKHBrZ1tESVNUX1RBR1NdW3RhZ10pKSB7XG4gICAgICBpZiAoIXNlbXZlci5wYXJzZShwa2dbRElTVF9UQUdTXVt0YWddLCB0cnVlKSkge1xuICAgICAgICAvLyBpZiB0aGUgdmVyc2lvbiBpcyBpbnZhbGlkLCBkZWxldGUgdGhlIGRpc3QtdGFnIGVudHJ5XG4gICAgICAgIGRlbGV0ZSBwa2dbRElTVF9UQUdTXVt0YWddO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwYXJzZUludGVydmFsVGFibGUgPSB7XG4gICcnOiAxMDAwLFxuICBtczogMSxcbiAgczogMTAwMCxcbiAgbTogNjAgKiAxMDAwLFxuICBoOiA2MCAqIDYwICogMTAwMCxcbiAgZDogODY0MDAwMDAsXG4gIHc6IDcgKiA4NjQwMDAwMCxcbiAgTTogMzAgKiA4NjQwMDAwMCxcbiAgeTogMzY1ICogODY0MDAwMDAsXG59O1xuXG4vKipcbiAqIFBhcnNlIGFuIGludGVybmFsIHN0cmluZyB0byBudW1iZXJcbiAqIEBwYXJhbSB7Kn0gaW50ZXJ2YWxcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW50ZXJ2YWwoaW50ZXJ2YWw6IGFueSk6IG51bWJlciB7XG4gIGlmICh0eXBlb2YgaW50ZXJ2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGludGVydmFsICogMTAwMDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gMDtcbiAgbGV0IGxhc3Rfc3VmZml4ID0gSW5maW5pdHk7XG4gIGludGVydmFsLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoeCk6IHZvaWQge1xuICAgIGlmICgheCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBtID0geC5tYXRjaCgvXigoMHxbMS05XVswLTldKikoXFwuWzAtOV0rKT8pKG1zfHN8bXxofGR8d3xNfHl8KSQvKTtcbiAgICBpZiAoIW0gfHwgcGFyc2VJbnRlcnZhbFRhYmxlW21bNF1dID49IGxhc3Rfc3VmZml4IHx8IChtWzRdID09PSAnJyAmJiBsYXN0X3N1ZmZpeCAhPT0gSW5maW5pdHkpKSB7XG4gICAgICB0aHJvdyBFcnJvcignaW52YWxpZCBpbnRlcnZhbDogJyArIGludGVydmFsKTtcbiAgICB9XG4gICAgbGFzdF9zdWZmaXggPSBwYXJzZUludGVydmFsVGFibGVbbVs0XV07XG4gICAgcmVzdWx0ICs9IE51bWJlcihtWzFdKSAqIHBhcnNlSW50ZXJ2YWxUYWJsZVttWzRdXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZWN0IHJ1bm5pbmcgcHJvdG9jb2wgKGh0dHAgb3IgaHR0cHMpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRXZWJQcm90b2NvbChoZWFkZXJQcm90b2NvbDogc3RyaW5nIHwgdm9pZCwgcHJvdG9jb2w6IHN0cmluZyk6IHN0cmluZyB7XG4gIGxldCByZXR1cm5Qcm90b2NvbDtcbiAgY29uc3QgWywgZGVmYXVsdFByb3RvY29sXSA9IHZhbGlkUHJvdG9jb2xzO1xuICAvLyBIQVByb3h5IHZhcmlhbnQgbWlnaHQgcmV0dXJuIGh0dHAsaHR0cCB3aXRoIFgtRm9yd2FyZGVkLVByb3RvXG4gIGlmICh0eXBlb2YgaGVhZGVyUHJvdG9jb2wgPT09ICdzdHJpbmcnICYmIGhlYWRlclByb3RvY29sICE9PSAnJykge1xuICAgIGRlYnVnKCdoZWFkZXIgcHJvdG9jb2w6ICVvJywgcHJvdG9jb2wpO1xuICAgIGNvbnN0IGNvbW1hSW5kZXggPSBoZWFkZXJQcm90b2NvbC5pbmRleE9mKCcsJyk7XG4gICAgcmV0dXJuUHJvdG9jb2wgPSBjb21tYUluZGV4ID4gMCA/IGhlYWRlclByb3RvY29sLnN1YnN0cigwLCBjb21tYUluZGV4KSA6IGhlYWRlclByb3RvY29sO1xuICB9IGVsc2Uge1xuICAgIGRlYnVnKCdyZXEgcHJvdG9jb2w6ICVvJywgaGVhZGVyUHJvdG9jb2wpO1xuICAgIHJldHVyblByb3RvY29sID0gcHJvdG9jb2w7XG4gIH1cblxuICByZXR1cm4gdmFsaWRQcm90b2NvbHMuaW5jbHVkZXMocmV0dXJuUHJvdG9jb2wpID8gcmV0dXJuUHJvdG9jb2wgOiBkZWZhdWx0UHJvdG9jb2w7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMYXRlc3RWZXJzaW9uKHBrZ0luZm86IFBhY2thZ2UpOiBzdHJpbmcge1xuICByZXR1cm4gcGtnSW5mb1tESVNUX1RBR1NdLmxhdGVzdDtcbn1cblxuZXhwb3J0IGNvbnN0IEVycm9yQ29kZSA9IHtcbiAgZ2V0Q29uZmxpY3QsXG4gIGdldEJhZERhdGEsXG4gIGdldEJhZFJlcXVlc3QsXG4gIGdldEludGVybmFsRXJyb3IsXG4gIGdldFVuYXV0aG9yaXplZCxcbiAgZ2V0Rm9yYmlkZGVuLFxuICBnZXRTZXJ2aWNlVW5hdmFpbGFibGUsXG4gIGdldE5vdEZvdW5kLFxuICBnZXRDb2RlLFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQ29uZmlnRmlsZShjb25maWdQYXRoOiBzdHJpbmcpOiBhbnkge1xuICB0cnkge1xuICAgIGlmICgvXFwueWE/bWwkL2kudGVzdChjb25maWdQYXRoKSkge1xuICAgICAgcmV0dXJuIFlBTUwubG9hZChmcy5yZWFkRmlsZVN5bmMoY29uZmlnUGF0aCwgJ3V0Zi04JykpO1xuICAgIH1cbiAgICBkZWJ1ZygneWFtbCBwYXJzZWQnKTtcbiAgICByZXR1cm4gcmVxdWlyZShjb25maWdQYXRoKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCd5YW1sIHBhcnNlIGZhaWxlZCcpO1xuICAgIGlmIChlLmNvZGUgIT09ICdNT0RVTEVfTk9UX0ZPVU5EJykge1xuICAgICAgZS5tZXNzYWdlID0gQVBQX0VSUk9SLkNPTkZJR19OT1RfVkFMSUQ7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEVycm9yKGUpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgcGF0aCBhbHJlYWR5IGV4aXN0LlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb2xkZXJFeGlzdHMocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKHBhdGgpO1xuICAgIHJldHVybiBzdGF0LmlzRGlyZWN0b3J5KCk7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSBmaWxlIGFscmVhZHkgZXhpc3QuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aFxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGVFeGlzdHMocGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKHBhdGgpO1xuICAgIHJldHVybiBzdGF0LmlzRmlsZSgpO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0QnlOYW1lKHBhY2thZ2VzOiBhbnlbXSwgb3JkZXJBc2NlbmRpbmc6IGJvb2xlYW4gfCB2b2lkID0gdHJ1ZSk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIHBhY2thZ2VzLnNsaWNlKCkuc29ydChmdW5jdGlvbiAoYSwgYik6IG51bWJlciB7XG4gICAgY29uc3QgY29tcGFyYXRvck5hbWVzID0gYS5uYW1lLnRvTG93ZXJDYXNlKCkgPCBiLm5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIHJldHVybiBvcmRlckFzY2VuZGluZyA/IChjb21wYXJhdG9yTmFtZXMgPyAtMSA6IDEpIDogY29tcGFyYXRvck5hbWVzID8gMSA6IC0xO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFNjb3BlKHNjb3BlOiBzdHJpbmcsIHBhY2thZ2VOYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gYEAke3Njb3BlfS8ke3BhY2thZ2VOYW1lfWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVQcm9wZXJ0aWVzKHByb3BlcnRpZXNUb0RlbGV0ZTogc3RyaW5nW10sIG9iamVjdEl0ZW06IGFueSk6IGFueSB7XG4gIF8uZm9yRWFjaChwcm9wZXJ0aWVzVG9EZWxldGUsIChwcm9wZXJ0eSk6IGFueSA9PiB7XG4gICAgZGVsZXRlIG9iamVjdEl0ZW1bcHJvcGVydHldO1xuICB9KTtcblxuICByZXR1cm4gb2JqZWN0SXRlbTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEdyYXZhdGFyU3VwcG9ydChwa2dJbmZvOiBQYWNrYWdlLCBvbmxpbmUgPSB0cnVlKTogQXV0aG9yQXZhdGFyIHtcbiAgY29uc3QgcGtnSW5mb0NvcHkgPSB7IC4uLnBrZ0luZm8gfSBhcyBhbnk7XG4gIGNvbnN0IGF1dGhvcjogYW55ID0gXy5nZXQocGtnSW5mbywgJ2xhdGVzdC5hdXRob3InLCBudWxsKSBhcyBhbnk7XG4gIGNvbnN0IGNvbnRyaWJ1dG9yczogQXV0aG9yQXZhdGFyW10gPSBub3JtYWxpemVDb250cmlidXRvcnMoXy5nZXQocGtnSW5mbywgJ2xhdGVzdC5jb250cmlidXRvcnMnLCBbXSkpO1xuICBjb25zdCBtYWludGFpbmVycyA9IF8uZ2V0KHBrZ0luZm8sICdsYXRlc3QubWFpbnRhaW5lcnMnLCBbXSk7XG5cbiAgLy8gZm9yIGF1dGhvci5cbiAgaWYgKGF1dGhvciAmJiBfLmlzT2JqZWN0KGF1dGhvcikpIHtcbiAgICBjb25zdCB7IGVtYWlsIH0gPSBhdXRob3IgYXMgQXV0aG9yO1xuICAgIHBrZ0luZm9Db3B5LmxhdGVzdC5hdXRob3IuYXZhdGFyID0gZ2VuZXJhdGVHcmF2YXRhclVybChlbWFpbCwgb25saW5lKTtcbiAgfVxuXG4gIGlmIChhdXRob3IgJiYgXy5pc1N0cmluZyhhdXRob3IpKSB7XG4gICAgcGtnSW5mb0NvcHkubGF0ZXN0LmF1dGhvciA9IHtcbiAgICAgIGF2YXRhcjogR0VORVJJQ19BVkFUQVIsXG4gICAgICBlbWFpbDogJycsXG4gICAgICBhdXRob3IsXG4gICAgfTtcbiAgfVxuXG4gIC8vIGZvciBjb250cmlidXRvcnNcbiAgaWYgKF8uaXNFbXB0eShjb250cmlidXRvcnMpID09PSBmYWxzZSkge1xuICAgIHBrZ0luZm9Db3B5LmxhdGVzdC5jb250cmlidXRvcnMgPSBjb250cmlidXRvcnMubWFwKChjb250cmlidXRvcik6IEF1dGhvckF2YXRhciA9PiB7XG4gICAgICBpZiAoaXNPYmplY3QoY29udHJpYnV0b3IpKSB7XG4gICAgICAgIGNvbnRyaWJ1dG9yLmF2YXRhciA9IGdlbmVyYXRlR3JhdmF0YXJVcmwoY29udHJpYnV0b3IuZW1haWwsIG9ubGluZSk7XG4gICAgICB9IGVsc2UgaWYgKF8uaXNTdHJpbmcoY29udHJpYnV0b3IpKSB7XG4gICAgICAgIGNvbnRyaWJ1dG9yID0ge1xuICAgICAgICAgIGF2YXRhcjogR0VORVJJQ19BVkFUQVIsXG4gICAgICAgICAgZW1haWw6IGNvbnRyaWJ1dG9yLFxuICAgICAgICAgIG5hbWU6IGNvbnRyaWJ1dG9yLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udHJpYnV0b3I7XG4gICAgfSk7XG4gIH1cblxuICAvLyBmb3IgbWFpbnRhaW5lcnNcbiAgaWYgKF8uaXNFbXB0eShtYWludGFpbmVycykgPT09IGZhbHNlKSB7XG4gICAgcGtnSW5mb0NvcHkubGF0ZXN0Lm1haW50YWluZXJzID0gbWFpbnRhaW5lcnMubWFwKChtYWludGFpbmVyKTogdm9pZCA9PiB7XG4gICAgICBtYWludGFpbmVyLmF2YXRhciA9IGdlbmVyYXRlR3JhdmF0YXJVcmwobWFpbnRhaW5lci5lbWFpbCwgb25saW5lKTtcbiAgICAgIHJldHVybiBtYWludGFpbmVyO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHBrZ0luZm9Db3B5O1xufVxuXG4vKipcbiAqIHBhcnNlIHBhY2thZ2UgcmVhZG1lIC0gbWFya2Rvd24vYXNjaWlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrYWdlTmFtZSBuYW1lIG9mIHBhY2thZ2VcbiAqIEBwYXJhbSB7U3RyaW5nfSByZWFkbWUgcGFja2FnZSByZWFkbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHNhbml0aXp5UmVhZG1lIG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ30gY29udmVydGVkIGh0bWwgdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlUmVhZG1lKHBhY2thZ2VOYW1lOiBzdHJpbmcsIHJlYWRtZTogc3RyaW5nLCBvcHRpb25zOiB7IHBhdGhuYW1lPzogc3RyaW5nIHwgdm9pZCB9ID0ge30pOiBzdHJpbmcgfCB2b2lkIHtcbiAgaWYgKF8uaXNFbXB0eShyZWFkbWUpID09PSBmYWxzZSkge1xuICAgIHJldHVybiBzYW5pdGl6eVJlYWRtZShyZWFkbWUsIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gbG9ncyByZWFkbWUgbm90IGZvdW5kIGVycm9yXG4gIGxvZ2dlci5lcnJvcih7IHBhY2thZ2VOYW1lIH0sICdAe3BhY2thZ2VOYW1lfTogTm8gcmVhZG1lIGZvdW5kJyk7XG5cbiAgcmV0dXJuIHNhbml0aXp5UmVhZG1lKCdFUlJPUjogTm8gUkVBRE1FIGRhdGEgZm91bmQhJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFRva2VuKHR5cGU6IHN0cmluZywgdG9rZW46IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtfLmNhcGl0YWxpemUodHlwZSl9ICR7dG9rZW59YDtcbn1cblxuLyoqXG4gKiByZXR1cm4gcGFja2FnZSB2ZXJzaW9uIGZyb20gdGFyYmFsbCBuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFZlcnNpb25Gcm9tVGFyYmFsbChuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB2b2lkIHtcbiAgLy8gRklYTUU6IHdlIGtub3cgdGhlIHJlZ2V4IGlzIHZhbGlkLCBidXQgd2Ugc2hvdWxkIGltcHJvdmUgdGhpcyBwYXJ0IGFzIHRzIHN1Z2dlc3RcbiAgLy8gQHRzLWlnbm9yZVxuICByZXR1cm4gLy4rLShcXGQuKylcXC50Z3ovLnRlc3QobmFtZSkgPyBuYW1lLm1hdGNoKC8uKy0oXFxkLispXFwudGd6LylbMV0gOiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCB0eXBlIEF1dGhvckZvcm1hdCA9IEF1dGhvciB8IHN0cmluZyB8IG51bGwgfCBvYmplY3QgfCB2b2lkO1xuXG4vKipcbiAqIEZvcm1hdHMgYXV0aG9yIGZpZWxkIGZvciB3ZWJ1aS5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLm5wbWpzLmNvbS9maWxlcy9wYWNrYWdlLmpzb24jYXV0aG9yXG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R8dW5kZWZpbmVkfSBhdXRob3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEF1dGhvcihhdXRob3I6IEF1dGhvckZvcm1hdCk6IGFueSB7XG4gIGxldCBhdXRob3JEZXRhaWxzID0ge1xuICAgIG5hbWU6IERFRkFVTFRfVVNFUixcbiAgICBlbWFpbDogJycsXG4gICAgdXJsOiAnJyxcbiAgfTtcblxuICBpZiAoXy5pc05pbChhdXRob3IpKSB7XG4gICAgcmV0dXJuIGF1dGhvckRldGFpbHM7XG4gIH1cblxuICBpZiAoXy5pc1N0cmluZyhhdXRob3IpKSB7XG4gICAgYXV0aG9yRGV0YWlscyA9IHtcbiAgICAgIC4uLmF1dGhvckRldGFpbHMsXG4gICAgICBuYW1lOiBhdXRob3IgYXMgc3RyaW5nLFxuICAgIH07XG4gIH1cblxuICBpZiAoXy5pc09iamVjdChhdXRob3IpKSB7XG4gICAgYXV0aG9yRGV0YWlscyA9IHtcbiAgICAgIC4uLmF1dGhvckRldGFpbHMsXG4gICAgICAuLi4oYXV0aG9yIGFzIEF1dGhvciksXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBhdXRob3JEZXRhaWxzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIFVSSSBpcyBzdGFydGluZyB3aXRoIFwiaHR0cDovL1wiLCBcImh0dHBzOi8vXCIgb3IgXCIvL1wiXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0hUVFBQcm90b2NvbCh1cmk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICByZXR1cm4gL14oaHR0cHM/Oik/XFwvXFwvLy50ZXN0KHVyaSk7XG59XG5cbi8qKlxuICogQXBwbHkgd2hpdGVzcGFjZXMgYmFzZWQgb24gdGhlIGxlbmd0aFxuICogQHBhcmFtIHsqfSBzdHIgdGhlIGxvZyBtZXNzYWdlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYWQoc3RyLCBtYXgpOiBzdHJpbmcge1xuICBpZiAoc3RyLmxlbmd0aCA8IG1heCkge1xuICAgIHJldHVybiBzdHIgKyAnICcucmVwZWF0KG1heCAtIHN0ci5sZW5ndGgpO1xuICB9XG4gIHJldHVybiBzdHI7XG59XG5cbi8qKlxuICogcmV0dXJuIGEgbWFzcXVlcmFkZSBzdHJpbmcgd2l0aCBpdHMgZmlyc3QgYW5kIGxhc3Qge2NoYXJOdW19IGFuZCB0aHJlZSBkb3RzIGluIGJldHdlZW4uXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge051bWJlcn0gY2hhck51bVxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hc2soc3RyOiBzdHJpbmcsIGNoYXJOdW0gPSAzKTogc3RyaW5nIHtcbiAgcmV0dXJuIGAke3N0ci5zdWJzdHIoMCwgY2hhck51bSl9Li4uJHtzdHIuc3Vic3RyKC1jaGFyTnVtKX1gO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlU2NvcGVkVXJpKHBhY2thZ2VOYW1lKTogc3RyaW5nIHtcbiAgcmV0dXJuIHBhY2thZ2VOYW1lLnJlcGxhY2UoL1xcLy9nLCAnJTJmJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNEaWZmT25lS2V5KHZlcnNpb25zKTogYm9vbGVhbiB7XG4gIHJldHVybiBPYmplY3Qua2V5cyh2ZXJzaW9ucykubGVuZ3RoICE9PSAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNWZXJzaW9uVmFsaWQocGFja2FnZU1ldGEsIHBhY2thZ2VWZXJzaW9uKTogYm9vbGVhbiB7XG4gIGNvbnN0IGhhc1ZlcnNpb24gPSB0eXBlb2YgcGFja2FnZVZlcnNpb24gIT09ICd1bmRlZmluZWQnO1xuICBpZiAoIWhhc1ZlcnNpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBoYXNNYXRjaFZlcnNpb24gPSBPYmplY3Qua2V5cyhwYWNrYWdlTWV0YS52ZXJzaW9ucykuaW5jbHVkZXMocGFja2FnZVZlcnNpb24pO1xuICByZXR1cm4gaGFzTWF0Y2hWZXJzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNSZWxhdGVkVG9EZXByZWNhdGlvbihwa2dJbmZvOiBQYWNrYWdlKTogYm9vbGVhbiB7XG4gIGNvbnN0IHsgdmVyc2lvbnMgfSA9IHBrZ0luZm87XG4gIGZvciAoY29uc3QgdmVyc2lvbiBpbiB2ZXJzaW9ucykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmVyc2lvbnNbdmVyc2lvbl0sICdkZXByZWNhdGVkJykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVSTChwdWJsaWNVcmw6IHN0cmluZyB8IHZvaWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWQgPSBuZXcgVVJMKHB1YmxpY1VybCBhcyBzdHJpbmcpO1xuICAgIGlmICghdmFsaWRQcm90b2NvbHMuaW5jbHVkZXMocGFyc2VkLnByb3RvY29sLnJlcGxhY2UoJzonLCAnJykpKSB7XG4gICAgICB0aHJvdyBFcnJvcignaW52YWxpZCBwcm90b2NvbCcpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gVE9ETzogYWRkIGVycm9yIGxvZ2dlciBoZXJlXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0hvc3QodXJsOiBzdHJpbmcgPSAnJywgb3B0aW9ucyA9IHt9KTogYm9vbGVhbiB7XG4gIHJldHVybiB2YWxpZGF0b3IuaXNVUkwodXJsLCB7XG4gICAgcmVxdWlyZV9ob3N0OiB0cnVlLFxuICAgIGFsbG93X3RyYWlsaW5nX2RvdDogZmFsc2UsXG4gICAgcmVxdWlyZV92YWxpZF9wcm90b2NvbDogZmFsc2UsXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHJlcXVpcmVfcG9ydDogZmFsc2UsXG4gICAgcmVxdWlyZV90bGQ6IGZhbHNlLFxuICAgIC4uLm9wdGlvbnMsXG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHVibGljVXJsKHVybF9wcmVmaXg6IHN0cmluZyA9ICcnLCByZXEpOiBzdHJpbmcge1xuICBpZiAodmFsaWRhdGVVUkwocHJvY2Vzcy5lbnYuVkVSREFDQ0lPX1BVQkxJQ19VUkwgYXMgc3RyaW5nKSkge1xuICAgIGNvbnN0IGVudlVSTCA9IG5ldyBVUkwod3JhcFByZWZpeCh1cmxfcHJlZml4KSwgcHJvY2Vzcy5lbnYuVkVSREFDQ0lPX1BVQkxJQ19VUkwgYXMgc3RyaW5nKS5ocmVmO1xuICAgIGRlYnVnKCdwdWJsaWMgdXJsIGJ5IGVudiAlbycsIGVudlVSTCk7XG4gICAgcmV0dXJuIGVudlVSTDtcbiAgfSBlbHNlIGlmIChyZXEuZ2V0KCdob3N0JykpIHtcbiAgICBjb25zdCBob3N0ID0gcmVxLmdldCgnaG9zdCcpO1xuICAgIGlmICghaXNIb3N0KGhvc3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaG9zdCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm90b0hlYWRlciA9IHByb2Nlc3MuZW52LlZFUkRBQ0NJT19GT1JXQVJERURfUFJPVE8gPz8gSEVBREVSUy5GT1JXQVJERURfUFJPVE87XG4gICAgY29uc3QgcHJvdG9jb2wgPSBnZXRXZWJQcm90b2NvbChyZXEuZ2V0KHByb3RvSGVhZGVyLnRvTG93ZXJDYXNlKCkpLCByZXEucHJvdG9jb2wpO1xuICAgIGNvbnN0IGNvbWJpbmVkVXJsID0gY29tYmluZUJhc2VVcmwocHJvdG9jb2wsIGhvc3QsIHVybF9wcmVmaXgpO1xuICAgIGRlYnVnKCdwdWJsaWMgdXJsIGJ5IHJlcXVlc3QgJW8nLCBjb21iaW5lZFVybCk7XG4gICAgcmV0dXJuIGNvbWJpbmVkVXJsO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAnLyc7XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgYmFzZSB1cmwgZm9yIHJlZ2lzdHJ5LlxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlIHJlZ2lzdHJ5IHVybFxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tYmluZUJhc2VVcmwocHJvdG9jb2w6IHN0cmluZywgaG9zdDogc3RyaW5nLCBwcmVmaXg6IHN0cmluZyA9ICcnKTogc3RyaW5nIHtcbiAgZGVidWcoJ2NvbWJpbmVkIHByb3RvY29sICVvJywgcHJvdG9jb2wpO1xuICBkZWJ1ZygnY29tYmluZWQgaG9zdCAlbycsIGhvc3QpO1xuICBjb25zdCBuZXdQcmVmaXggPSB3cmFwUHJlZml4KHByZWZpeCk7XG4gIGRlYnVnKCdjb21iaW5lZCBwcmVmaXggJW8nLCBuZXdQcmVmaXgpO1xuICBjb25zdCBncm91cGVkVVJJID0gbmV3IFVSTCh3cmFwUHJlZml4KHByZWZpeCksIGAke3Byb3RvY29sfTovLyR7aG9zdH1gKTtcbiAgY29uc3QgcmVzdWx0ID0gZ3JvdXBlZFVSSS5ocmVmO1xuICBkZWJ1ZygnY29tYmluZWQgdXJsICVvJywgcmVzdWx0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBQcmVmaXgocHJlZml4OiBzdHJpbmcgfCB2b2lkKTogc3RyaW5nIHtcbiAgaWYgKHByZWZpeCA9PT0gJycgfHwgdHlwZW9mIHByZWZpeCA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJlZml4ID09PSBudWxsKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IGVsc2UgaWYgKCFwcmVmaXguc3RhcnRzV2l0aCgnLycpICYmIHByZWZpeC5lbmRzV2l0aCgnLycpKSB7XG4gICAgcmV0dXJuIGAvJHtwcmVmaXh9YDtcbiAgfSBlbHNlIGlmICghcHJlZml4LnN0YXJ0c1dpdGgoJy8nKSAmJiAhcHJlZml4LmVuZHNXaXRoKCcvJykpIHtcbiAgICByZXR1cm4gYC8ke3ByZWZpeH0vYDtcbiAgfSBlbHNlIGlmIChwcmVmaXguc3RhcnRzV2l0aCgnLycpICYmICFwcmVmaXguZW5kc1dpdGgoJy8nKSkge1xuICAgIHJldHVybiBgJHtwcmVmaXh9L2A7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByZWZpeDtcbiAgfVxufVxuIl19